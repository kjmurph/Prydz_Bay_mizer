---
title: "Prydz Bay mizer Model Optimization - Refined Strategy"
output: html_notebook
author: "Model Optimization - Refined"
date: "`r Sys.Date()`"
---

# Introduction

This refined optimization approach addresses key issues identified in initial testing:

1. **Selective parameter optimization**: Only optimize abundance/gamma for marine mammals, while allowing limited catchability variation for smaller species
2. **Enhanced whale prioritization**: Increased weighting for whale species (especially sperm and baleen whales)
3. **Stricter biomass stability criteria**: Tighter tolerance for rejecting unstable simulations
4. **Improved convergence**: Longer burn-in and more iterations

# Key Refinements Based on Test Results

- **Smaller, short-lived species** (krill, fishes) that previously fit well are now excluded from abundance/gamma optimization
- **Whale species** receive much higher priority weighting (5-10x)
- **Biomass stability tolerance** reduced from 0.1 to 0.05
- **Burn-in period** increased to 300 years
- **Steady-state tolerance** tightened to 0.0025

# Setup and Load Required Packages

```{r setup, message=FALSE, warning=FALSE}
# Load required libraries
library(mizer)
library(therMizer)
library(calibrar)
library(tidyverse)
library(parallel)
library(doParallel)
library(foreach)
library(gridExtra)
library(corrplot)
library(viridis)

# Source helper functions
source("Helper_Functions.R")

# Set seed for reproducibility
set.seed(42)

# Setup parallel processing with enhanced configuration
n_cores <- detectCores() - 2  # Leave one core free
n_cores <- min(n_cores, 8)    # Cap at 8 cores for optimization stability

# Check for parallel processing environment variable
use_parallel_env <- Sys.getenv("R_PARALLELIZE", "TRUE") == "TRUE"

# Detect system memory to optimize parallel processing
system_ram_gb <- tryCatch({
  if (.Platform$OS.type == "windows") {
    as.numeric(system('wmic computersystem get TotalPhysicalMemory /value', intern = TRUE)[3]) / 1e9
  } else {
    as.numeric(system("free -b | grep '^Mem' | awk '{print $2}'", intern = TRUE)) / 1e9
  }
}, error = function(e) 16) # Default to 16GB if detection fails

# Adjust cores based on memory (each core needs ~3GB for mizer simulations)
memory_limited_cores <- floor(system_ram_gb / 3) # Conservative estimate
n_cores <- min(n_cores, memory_limited_cores, 6) # Cap at 6 for stability

# Final decision on parallel processing
use_parallel <- use_parallel_env && n_cores > 1

cat("=== PARALLEL PROCESSING SETUP ===\n")
cat("System cores detected:", detectCores(), "\n")
cat("System RAM:", round(system_ram_gb, 1), "GB\n")
cat("Environment variable R_PARALLELIZE:", Sys.getenv("R_PARALLELIZE", "TRUE"), "\n")
cat("Parallel processing enabled:", use_parallel, "\n")
if (use_parallel) {
  cat("Cores to use:", n_cores, "\n")
  cat("Expected memory usage:", round(n_cores * 3, 1), "GB\n")
} else {
  cat("Running in sequential mode\n")
}
cat("\n")

# Create plots directory if it doesn't exist
if (!dir.exists("plots")) {
  dir.create("plots", recursive = TRUE)
  cat("Created plots directory\n")
}

# Set up parallel backend if enabled
if (use_parallel) {
  cat("Registering parallel backend...\n")
  cl <- makeCluster(n_cores, type = "PSOCK")
  registerDoParallel(cl)
  
  # Confirm parallel backend is active
  cat("Parallel workers available:", getDoParWorkers(), "\n")
  
  # Function to cleanup cluster on exit
  cleanup_cluster <- function() {
    if (exists("cl") && !is.null(cl)) {
      tryCatch({
        stopCluster(cl)
        registerDoSEQ()
        cat("Parallel cluster stopped\n")
      }, error = function(e) {
        cat("Warning: Could not stop cluster properly\n")
      })
    }
  }
  
  # Register cleanup function
  reg.finalizer(environment(), cleanup_cluster, onexit = TRUE)
} else {
  cl <- NULL
}
```

# Load Model Parameters and Data

```{r load-data}
# Load base parameters
params_new_v4 <- readRDS("params_steady_state_2011_2020_tol_0.00025.RDS")

# Load climate forcings
extended_ocean_temp <- readRDS("temperature_forcing_1841_2010.rds")
constant_array_temp <- readRDS("constant_array_temp.RDS")
constant_array_temp_1841 <- readRDS("constant_array_temp_1841.RDS")

extended_n_pp_array <- readRDS("phytoplankton_forcing_1841_2010.rds")
constant_array_n_pp <- readRDS("constant_array_n_pp.RDS")
constant_array_n_pp_1841 <- readRDS("constant_array_n_pp_1841.RDS")

# Load effort data
combined_effort_array <- readRDS("effort_array_1841_2010.rds")

# Load observed yield data
yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")

# Setup base parameters with climate forcings
params_base <- upgradeTherParams(params_new_v4,
                                 ocean_temp_array = extended_ocean_temp,
                                 n_pp_array = extended_n_pp_array,
                                 aerobic_effect = FALSE, 
                                 metabolism_effect = TRUE)

# For fishing-only scenario (constant climate)
params_fishing_only <- upgradeTherParams(params_new_v4,
                                         ocean_temp_array = constant_array_temp_1841,
                                         n_pp_array = constant_array_n_pp_1841,
                                         aerobic_effect = FALSE, 
                                         metabolism_effect = TRUE)
```

# Define Refined Optimization Parameters

```{r define-parameters}
# REFINED STRATEGY: Only optimize abundance/gamma for marine mammals
# Allow limited catchability variation for all fished species

# Species groups
marine_mammal_species <- c("minke whales", "orca", "sperm whales", "baleen whales")
other_fished_species <- c("antarctic krill", "bathypelagic fishes", 
                         "shelf and coastal fishes", "squids", "toothfishes")
all_fished_species <- c(other_fished_species, marine_mammal_species)

# 1. ABUNDANCE SCALING - ONLY FOR MARINE MAMMALS
abundance_bounds <- data.frame(
  species = marine_mammal_species,
  lower = log(1),     # Allow 1x to 200x scaling (wider range for whales)
  upper = log(200),   # Increased upper bound for historical whaling impact
  initial = log(c(20, 5, 30, 30))  # Higher initial guesses based on test results
)

# 2. CATCHABILITY BOUNDS - DIFFERENTIATED BY SPECIES GROUP
gear_df <- gear_params(params_base)

# Separate catchability bounds for different groups
whale_catchability_idx <- which(gear_df$species %in% marine_mammal_species & gear_df$catchability > 0)
other_catchability_idx <- which(gear_df$species %in% other_fished_species & gear_df$catchability > 0)

# Wider bounds for whale catchability (they need more adjustment)
whale_catchability_bounds <- data.frame(
  gear = gear_df$gear[whale_catchability_idx],
  species = gear_df$species[whale_catchability_idx],
  lower = gear_df$catchability[whale_catchability_idx] * 0.1,  # 10% to 10x current
  upper = pmin(1, gear_df$catchability[whale_catchability_idx] * 10),
  initial = gear_df$catchability[whale_catchability_idx]
)

# Narrower bounds for other species (they already fit well)
other_catchability_bounds <- data.frame(
  gear = gear_df$gear[other_catchability_idx],
  species = gear_df$species[other_catchability_idx],
  lower = gear_df$catchability[other_catchability_idx] * 0.5,  # 50% to 150% of current
  upper = pmin(1, gear_df$catchability[other_catchability_idx] * 1.5),
  initial = gear_df$catchability[other_catchability_idx]
)

# Combine catchability bounds
catchability_bounds <- rbind(whale_catchability_bounds, other_catchability_bounds)

# Ensure initial values are within bounds
catchability_bounds$initial <- pmax(catchability_bounds$lower,
                                    pmin(catchability_bounds$upper,
                                         catchability_bounds$initial))

# 3. GAMMA (SEARCH RATE) - ONLY FOR MARINE MAMMALS
species_params_df <- species_params(params_base)
whale_gamma <- species_params_df$gamma[species_params_df$species %in% marine_mammal_species]

gamma_bounds <- data.frame(
  species = marine_mammal_species,
  lower = log(whale_gamma * 0.1),   # 10% to 10x range
  upper = log(whale_gamma * 10),
  initial = log(whale_gamma)
)

# Combine all parameters
n_params <- nrow(abundance_bounds) + nrow(catchability_bounds) + nrow(gamma_bounds)
param_names <- c(
  paste0("abundance_", abundance_bounds$species),
  paste0("catchability_", catchability_bounds$species, "_", catchability_bounds$gear),
  paste0("gamma_", gamma_bounds$species)
)

# Initial parameter vector
initial_params <- c(
  abundance_bounds$initial,
  catchability_bounds$initial,
  gamma_bounds$initial
)
names(initial_params) <- param_names

# Lower bounds
lower_bounds <- c(
  abundance_bounds$lower,
  catchability_bounds$lower,
  gamma_bounds$lower
)
names(lower_bounds) <- param_names

# Upper bounds
upper_bounds <- c(
  abundance_bounds$upper,
  catchability_bounds$upper,
  gamma_bounds$upper
)
names(upper_bounds) <- param_names

# Verify bounds
if (any(initial_params < lower_bounds) || any(initial_params > upper_bounds)) {
  cat("Adjusting parameters to be within bounds...\n")
  initial_params <- pmax(lower_bounds, pmin(upper_bounds, initial_params))
}

cat("\n=== REFINED OPTIMIZATION STRATEGY ===\n")
cat("Total parameters to optimize:", n_params, "\n")
cat("  - Marine mammal abundance scaling:", nrow(abundance_bounds), "\n")
cat("  - Whale catchability:", nrow(whale_catchability_bounds), "\n")
cat("  - Other species catchability (limited):", nrow(other_catchability_bounds), "\n")
cat("  - Marine mammal gamma:", nrow(gamma_bounds), "\n\n")

# Display parameter summary
param_summary <- data.frame(
  Parameter = param_names,
  Lower = round(lower_bounds, 4),
  Initial = round(initial_params, 4),
  Upper = round(upper_bounds, 4),
  Range = ifelse(grepl("abundance|gamma", param_names), "Wide", 
                 ifelse(grepl("minke|sperm|baleen|orca", param_names), "Wide", "Narrow"))
)
print(head(param_summary, 20))
```

# Define Helper Functions with Stricter Stability Checks

```{r helper-functions}
# Function to apply parameters to mizer model
apply_parameters_refined <- function(params_vector, base_params, 
                                    abundance_bounds, 
                                    catchability_bounds,
                                    gamma_bounds) {
  
  # Create a copy of base parameters
  new_params <- base_params
  
  # Extract parameter values
  n_abundance <- nrow(abundance_bounds)
  n_catchability <- nrow(catchability_bounds)
  n_gamma <- nrow(gamma_bounds)
  
  # Apply abundance scaling (only marine mammals)
  if (n_abundance > 0) {
    abundance_values <- exp(params_vector[1:n_abundance])
    sp_params <- species_params(new_params)
    
    for (i in seq_along(abundance_bounds$species)) {
      sp_idx <- which(sp_params$species == abundance_bounds$species[i])
      if (length(sp_idx) > 0) {
        new_params@initial_n[sp_idx,] <- base_params@initial_n[sp_idx,] * abundance_values[i]
      }
    }
  }
  
  # Apply catchability values
  if (n_catchability > 0) {
    catchability_values <- params_vector[(n_abundance + 1):(n_abundance + n_catchability)]
    gear_df <- gear_params(new_params)
    
    for (i in 1:n_catchability) {
      gear_idx <- which(gear_df$species == catchability_bounds$species[i] & 
                       gear_df$gear == catchability_bounds$gear[i])
      if (length(gear_idx) > 0) {
        gear_df$catchability[gear_idx] <- catchability_values[i]
      }
    }
    gear_params(new_params) <- gear_df
  }
  
  # Apply gamma values (only marine mammals)
  if (n_gamma > 0) {
    gamma_values <- exp(params_vector[(n_abundance + n_catchability + 1):length(params_vector)])
    
    for (i in seq_along(gamma_bounds$species)) {
      sp_idx <- which(species_params(new_params)$species == gamma_bounds$species[i])
      if (length(sp_idx) > 0) {
        species_params(new_params)$gamma[sp_idx] <- gamma_values[i]
      }
    }
  }
  
  return(new_params)
}

# Stricter biomass stability check
check_biomass_stability_strict <- function(sim_object, tolerance = 0.05, check_years = 20) {
  # Check stability over last 20 years with tighter tolerance
  biomass <- getBiomass(sim_object)
  n_years <- nrow(biomass)
  
  if (n_years < check_years) {
    return(FALSE)
  }
  
  # Calculate coefficient of variation for each species
  last_years <- biomass[(n_years - check_years + 1):n_years, ]
  cv_by_species <- apply(last_years, 2, function(x) sd(x) / mean(x))
  
  # Stricter criteria: CV should be less than tolerance for all species
  stable <- all(cv_by_species < tolerance, na.rm = TRUE)
  
  # Also check for extreme biomass changes
  first_year <- last_years[1, ]
  last_year <- last_years[check_years, ]
  rel_change <- abs((last_year - first_year) / first_year)
  
  # No species should have more than 20% change
  stable <- stable && all(rel_change < 0.2, na.rm = TRUE)
  
  return(stable)
}

# Enhanced burn-in with stricter stability requirements
run_with_enhanced_burnin <- function(params, effort_array, 
                                    burnin_years = 300,  # Increased
                                    spinup_years = 118,
                                    t_start = 1841,
                                    sim_years = 170,
                                    tol = 0.0025,  # Tighter steady-state tolerance
                                    t_max = 2000,
                                    biomass_tol = 0.05,  # Stricter
                                    reject_unstable = TRUE) {
  
  # Step 1: Run to steady state with tighter tolerance
  params_steady <- tryCatch({
    steady(params, tol = tol, t_max = t_max, preserve = c("erepro"))
  }, error = function(e) {
    message("Steady state failed, using original params")
    return(params)
  })
  
  # Step 2: Extended burn-in
  sim_burnin <- project(params_steady,
                        t_start = t_start - burnin_years,
                        t_max = burnin_years,
                        effort = 0)
  
  # Strict stability check
  is_stable <- check_biomass_stability_strict(sim_burnin, tolerance = biomass_tol)
  
  if (!is_stable && reject_unstable) {
    return(NULL)  # Reject unstable simulations
  }
  
  # Step 3: Spinup period
  if (spinup_years > 0) {
    sim_spinup <- project(params_steady,
                         initial_n = sim_burnin@n[burnin_years,,],
                         t_start = t_start,
                         t_max = spinup_years,
                         effort = 0)
    
    # Step 4: Main simulation
    sim_main <- project(params_steady,
                       initial_n = sim_spinup@n[spinup_years,,],
                       t_start = t_start,
                       t_max = sim_years,
                       effort = effort_array)
  } else {
    sim_main <- project(params_steady,
                       initial_n = sim_burnin@n[burnin_years,,],
                       t_start = t_start,
                       t_max = sim_years,
                       effort = effort_array)
  }
  
  attr(sim_main, "biomass_stable") <- is_stable
  return(sim_main)
}
```

# Enhanced Plotting Functions from Script 11

```{r plotting-functions}
# Plotting functions integrated from script 11

# Enhanced yield comparison plot
plot_yield_comparison_enhanced <- function(sim_object,
                                         yield_obs_data,
                                         species_labels = NULL,
                                         plot_title = "Modeled vs. Observed Yield",
                                         save_plot = TRUE,
                                         filename = "yield_comparison.png") {
  
  # Default species labels
  if (is.null(species_labels)) {
    species_labels <- c("Antarctic krill", "Bathypelagic fishes",
                       "Shelf & Coastal fishes", "Squids", "Toothfishes",
                       "Antarctic minke whales", "Orcas", "Sperm whales",
                       "Baleen whales")
    names(species_labels) <- c("antarctic krill", "bathypelagic fishes",
                              "shelf and coastal fishes", "squids", "toothfishes",
                              "minke whales", "orca", "sperm whales", "baleen whales")
  }
  
  # Get modeled yield data
  mod_yield <- getYield(sim_object)
  df_mod <- reshape2::melt(mod_yield)
  names(df_mod) <- c("Year", "Species", "Yield")
  
  # Create the plot
  p_yield <- ggplot() +
    # Model predictions as lines
    geom_line(data = df_mod,
              aes(x = Year, y = Yield, color = Species),
              size = 1.2, alpha = 0.8) +
    # Observed data points
    geom_point(data = yield_obs_data,
               aes(x = Year, y = Yield, color = Species),
               size = 2, alpha = 0.7) +
    geom_point(data = yield_obs_data,
               aes(x = Year, y = Yield),
               shape = 1, size = 2, colour = "black") +
    # Faceting
    facet_wrap(~Species, scales = "free_y",
               labeller = labeller(Species = species_labels)) +
    # Styling
    geom_vline(xintercept = c(1961, 2010), linetype = "dashed", alpha = 0.5) +
    theme_bw() +
    theme(legend.position = "none",
          strip.text = element_text(size = 10, face = "bold"),
          axis.text = element_text(size = 9)) +
    labs(title = plot_title,
         x = "Year",
         y = "Yield (tonnes)") +
    scale_color_viridis_d(option = "plasma", end = 0.9)
  
  if (save_plot) {
    ggsave(paste0("plots/", filename), p_yield,
           width = 14, height = 10, dpi = 300)
    cat("Saved plot:", paste0("plots/", filename), "\n")
  }
  
  return(p_yield)
}

# Enhanced biomass trajectory plot
plot_biomass_trajectories <- function(sim_object,
                                    obs_biomass_data = NULL,
                                    plot_title = "Biomass Trajectories",
                                    save_plot = TRUE,
                                    filename = "biomass_trajectories.png") {
  
  # Get modeled biomass
  biomass <- getBiomass(sim_object)
  biomass_df <- reshape2::melt(biomass)
  names(biomass_df) <- c("Year", "Species", "Biomass")
  
  p_biomass <- ggplot(biomass_df, aes(x = Year, y = Biomass, color = Species)) +
    geom_line(size = 1.2, alpha = 0.8) +
    facet_wrap(~Species, scales = "free_y", ncol = 4) +
    theme_bw() +
    theme(legend.position = "none",
          strip.text = element_text(size = 9, face = "bold"),
          axis.text = element_text(size = 8)) +
    labs(title = plot_title,
         x = "Year",
         y = "Biomass") +
    geom_vline(xintercept = c(1961, 2010), linetype = "dashed", alpha = 0.5) +
    scale_color_viridis_d(option = "viridis", end = 0.9)
  
  # Add observed biomass if provided
  if (!is.null(obs_biomass_data)) {
    obs_years <- 2010:2020
    obs_biomass_ts <- obs_biomass_data %>%
      crossing(Year = obs_years)
    
    p_biomass <- p_biomass +
      geom_point(data = obs_biomass_ts,
                 aes(x = Year, y = ObsBiomass),
                 color = "red", size = 1.5, alpha = 0.7) +
      geom_ribbon(data = obs_biomass_ts,
                  aes(x = Year, ymin = ObsBiomass * 0.9, ymax = ObsBiomass * 1.1),
                  fill = "red", alpha = 0.1)
  }
  
  if (save_plot) {
    ggsave(paste0("plots/", filename), p_biomass,
           width = 16, height = 12, dpi = 300)
    cat("Saved plot:", paste0("plots/", filename), "\n")
  }
  
  return(p_biomass)
}

# Function to plot parameter evolution
plot_parameter_evolution <- function(optimization_history,
                                   save_plot = TRUE,
                                   filename = "parameter_evolution.png") {
  
  if (length(optimization_history) == 0) {
    cat("No optimization history available\n")
    return(NULL)
  }
  
  # Convert history to data frame
  df_history <- data.frame(
    Iteration = 1:length(optimization_history),
    RMSE = optimization_history
  )
  
  # Calculate moving average
  window_size <- min(20, floor(length(df_history$RMSE) / 10))
  if (window_size > 2) {
    df_history$RMSE_smooth <- stats::filter(df_history$RMSE,
                                           rep(1/window_size, window_size),
                                           sides = 1)
  }
  
  p_evolution <- ggplot(df_history, aes(x = Iteration)) +
    geom_line(aes(y = RMSE), color = "lightblue", alpha = 0.6, size = 0.5) +
    geom_point(aes(y = RMSE), size = 0.8, alpha = 0.4, color = "steelblue") +
    {if(window_size > 2) geom_line(aes(y = RMSE_smooth),
                                  color = "darkblue", size = 1.2)} +
    geom_hline(yintercept = min(df_history$RMSE, na.rm = TRUE),
               color = "red", linetype = "dashed", size = 1) +
    theme_bw() +
    labs(title = "Optimization Progress",
         subtitle = paste("Best RMSE:", round(min(df_history$RMSE, na.rm = TRUE), 3)),
         x = "Iteration",
         y = "RMSE") +
    theme(text = element_text(size = 12))
  
  if (save_plot) {
    ggsave(paste0("plots/", filename), p_evolution,
           width = 10, height = 6, dpi = 300)
    cat("Saved plot:", paste0("plots/", filename), "\n")
  }
  
  return(p_evolution)
}

# Species-specific RMSE plot
plot_species_rmse <- function(rmse_by_species,
                            save_plot = TRUE,
                            filename = "species_rmse.png") {
  
  p_rmse <- ggplot(rmse_by_species, aes(x = reorder(Species, RMSE), y = RMSE)) +
    geom_bar(stat = "identity", fill = "steelblue", alpha = 0.7) +
    geom_text(aes(label = round(RMSE, 2)), hjust = -0.1, size = 3) +
    coord_flip() +
    theme_bw() +
    labs(title = "Species-specific RMSE (Optimal Model)",
         x = "Species",
         y = "RMSE") +
    theme(text = element_text(size = 12))
  
  if (save_plot) {
    ggsave(paste0("plots/", filename), p_rmse,
           width = 10, height = 8, dpi = 300)
    cat("Saved plot:", paste0("plots/", filename), "\n")
  }
  
  return(p_rmse)
}
```

# Define Parallel-Aware Objective Function

```{r parallel-objective-function}
# Initialize global tracking variables for progress monitoring
.GlobalEnv$iter_count <- 0
.GlobalEnv$best_rmse <- Inf
.GlobalEnv$best_params <- NULL
.GlobalEnv$rmse_history <- numeric()
.GlobalEnv$params_history <- list()
.GlobalEnv$start_time <- Sys.time()

# Enhanced parallel-compatible objective function
objective_function_parallel <- function(params_vector,
                                      base_params,
                                      abundance_bounds,
                                      catchability_bounds,
                                      gamma_bounds,
                                      effort_array,
                                      yield_obs_data,
                                      year_range = c(1961, 2010),
                                      burnin_years = 300,
                                      spinup_years = 118,
                                      t_start = 1841,
                                      sim_years = 170,
                                      species_weights = NULL,
                                      reject_unstable = TRUE,
                                      biomass_tol = 0.05,
                                      verbose = FALSE,
                                      parallel_id = NULL) {
  
  # Parallel-safe progress tracking
  if (!is.null(parallel_id)) {
    # In parallel mode, save individual results to temporary files
    temp_file <- paste0("temp_parallel_", parallel_id, "_", Sys.getpid(), ".rds")
  }
  
  # Apply parameters
  test_params <- apply_parameters_refined(params_vector, base_params,
                                        abundance_bounds,
                                        catchability_bounds,
                                        gamma_bounds)
  
  # Run simulation with error handling for parallel execution
  sim_result <- tryCatch({
    run_with_enhanced_burnin(test_params, effort_array,
                           burnin_years = burnin_years,
                           spinup_years = spinup_years,
                           t_start = t_start,
                           sim_years = sim_years,
                           biomass_tol = biomass_tol,
                           reject_unstable = reject_unstable,
                           tol = 0.0025)
  }, error = function(e) {
    if (verbose) cat("Simulation failed (parallel_id:", parallel_id, "):", e$message, "\n")
    return(NULL)
  })
  
  # Calculate RMSE
  if (is.null(sim_result)) {
    rmse <- 1e6
  } else {
    # Calculate RMSE with species weights
    mod_yield <- getYield(sim_result)
    df_mod <- reshape2::melt(mod_yield)
    names(df_mod) <- c("Year", "Species", "Yield")
    
    # Filter by year range
    df_mod <- df_mod[df_mod$Year >= min(year_range) & df_mod$Year <= max(year_range), ]
    yield_obs_filtered <- yield_obs_data[yield_obs_data$Year >= min(year_range) &
                                        yield_obs_data$Year <= max(year_range), ]
    
    # Merge data
    comparison <- merge(df_mod, yield_obs_filtered,
                      by = c("Year", "Species"),
                      suffixes = c("_mod", "_obs"))
    
    # Calculate weighted RMSE
    if (!is.null(species_weights)) {
      comparison <- comparison %>%
        left_join(species_weights, by = "Species") %>%
        mutate(weight = ifelse(is.na(weight), 1, weight))
      
      rmse_by_species <- comparison %>%
        group_by(Species, weight) %>%
        summarise(
          rmse = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)),
          n_obs = n(),
          .groups = 'drop'
        )
      
      total_rmse <- weighted.mean(rmse_by_species$rmse,
                                 rmse_by_species$weight * rmse_by_species$n_obs,
                                 na.rm = TRUE)
    } else {
      total_rmse <- sqrt(mean((comparison$Yield_mod - comparison$Yield_obs)^2, na.rm = TRUE))
    }
    
    rmse <- total_rmse
  }
  
  # Handle NaN or Inf values
  if (is.nan(rmse) || is.infinite(rmse)) {
    rmse <- 1e6
  }
  
  # Save result to temp file if in parallel mode
  if (!is.null(parallel_id)) {
    result <- list(
      parallel_id = parallel_id,
      params = params_vector,
      rmse = rmse,
      timestamp = Sys.time(),
      pid = Sys.getpid()
    )
    saveRDS(result, temp_file)
  }
  
  return(rmse)
}

# Function to plot optimization progress
plot_optimization_progress <- function() {
  if (length(.GlobalEnv$rmse_history) > 10) {
    df <- data.frame(
      Iteration = 1:length(.GlobalEnv$rmse_history),
      RMSE = .GlobalEnv$rmse_history
    )
    
    # Calculate moving average
    window_size <- min(50, floor(length(df$RMSE) / 10))
    if (window_size > 2) {
      df$RMSE_smooth <- stats::filter(df$RMSE, rep(1/window_size, window_size), sides = 1)
    }
    
    p <- ggplot(df, aes(x = Iteration)) +
      geom_line(aes(y = RMSE), color = "lightblue", alpha = 0.5) +
      geom_point(aes(y = RMSE), size = 0.5, alpha = 0.3) +
      {if(window_size > 2) geom_line(aes(y = RMSE_smooth), color = "blue", size = 1)} +
      geom_hline(yintercept = min(df$RMSE, na.rm = TRUE),
                 color = "red", linetype = "dashed") +
      labs(title = paste("Optimization Progress - Best RMSE:",
                        round(min(df$RMSE, na.rm = TRUE), 3)),
           subtitle = paste("Current iteration:", max(df$Iteration),
                          "| Runtime:", round(difftime(Sys.time(),
                                                      .GlobalEnv$start_time,
                                                      units = "hours"), 2), "hours"),
           x = "Iteration",
           y = "RMSE") +
      theme_minimal()
    
    print(p)
    
    # Save progress plot
    ggsave("plots/optimization_progress.png", p,
           width = 10, height = 6, dpi = 300)
  }
}

# Refined objective function with auto-save and progress monitoring
objective_function_refined <- function(params_vector,
                                      base_params,
                                      abundance_bounds,
                                      catchability_bounds,
                                      gamma_bounds,
                                      effort_array,
                                      yield_obs_data,
                                      year_range = c(1961, 2010),
                                      burnin_years = 300,
                                      spinup_years = 118,
                                      t_start = 1841,
                                      sim_years = 170,
                                      species_weights = NULL,
                                      reject_unstable = TRUE,
                                      biomass_tol = 0.05,
                                      save_interval = 50,
                                      plot_interval = 100,
                                      verbose = FALSE) {
  
  # Update iteration counter
  .GlobalEnv$iter_count <- .GlobalEnv$iter_count + 1
  
  if (verbose) {
    cat("\n--- Iteration", .GlobalEnv$iter_count, "---\n")
  }
  
  # Apply parameters
  test_params <- apply_parameters_refined(params_vector, base_params,
                                         abundance_bounds,
                                         catchability_bounds,
                                         gamma_bounds)
  
  # Run simulation with strict stability checks
  sim_result <- tryCatch({
    run_with_enhanced_burnin(test_params, effort_array,
                            burnin_years = burnin_years,
                            spinup_years = spinup_years,
                            t_start = t_start,
                            sim_years = sim_years,
                            biomass_tol = biomass_tol,
                            reject_unstable = reject_unstable,
                            tol = 0.0025)
  }, error = function(e) {
    if (verbose) cat("Simulation failed:", e$message, "\n")
    return(NULL)
  })
  
  # Reject failed or unstable simulations
  if (is.null(sim_result)) {
    if (verbose) cat("Simulation rejected (failed or unstable)\n")
    rmse <- 1e6
  } else {
    # Calculate RMSE with species-specific weights
    mod_yield <- getYield(sim_result)
    df_mod <- reshape2::melt(mod_yield)
    names(df_mod) <- c("Year", "Species", "Yield")
    
    # Filter by year range
    df_mod <- df_mod[df_mod$Year >= min(year_range) & df_mod$Year <= max(year_range), ]
    yield_obs_filtered <- yield_obs_data[yield_obs_data$Year >= min(year_range) &
                                         yield_obs_data$Year <= max(year_range), ]
    
    # Merge data
    comparison <- merge(df_mod, yield_obs_filtered,
                       by = c("Year", "Species"),
                       suffixes = c("_mod", "_obs"))
    
    # Calculate weighted RMSE
    if (!is.null(species_weights)) {
      # Apply species-specific weights
      comparison <- comparison %>%
        left_join(species_weights, by = "Species") %>%
        mutate(weight = ifelse(is.na(weight), 1, weight))
      
      # Calculate weighted RMSE by species
      rmse_by_species <- comparison %>%
        group_by(Species, weight) %>%
        summarise(
          rmse = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)),
          n_obs = n(),
          .groups = 'drop'
        )
      
      # Weighted average
      total_rmse <- weighted.mean(rmse_by_species$rmse,
                                  rmse_by_species$weight * rmse_by_species$n_obs,
                                  na.rm = TRUE)
      
      if (verbose) {
        cat("Species RMSE (weighted):\n")
        print(rmse_by_species)
      }
    } else {
      # Simple RMSE
      total_rmse <- sqrt(mean((comparison$Yield_mod - comparison$Yield_obs)^2, na.rm = TRUE))
    }
    
    rmse <- total_rmse
  }
  
  # Update history
  .GlobalEnv$rmse_history <- c(.GlobalEnv$rmse_history, rmse)
  
  # Track best result
  if (rmse < .GlobalEnv$best_rmse) {
    .GlobalEnv$best_rmse <- rmse
    .GlobalEnv$best_params <- params_vector
    cat("\n*** NEW BEST RMSE:", round(rmse, 3),
        "at iteration", .GlobalEnv$iter_count, "***\n")
    
    # Save best parameters immediately
    best_results <- list(
      iteration = .GlobalEnv$iter_count,
      best_rmse = .GlobalEnv$best_rmse,
      best_params = .GlobalEnv$best_params,
      param_names = names(params_vector),
      timestamp = Sys.time()
    )
    saveRDS(best_results, "optimization_best_params.RDS")
  }
  
  # Periodic checkpoint save
  if (.GlobalEnv$iter_count %% save_interval == 0) {
    checkpoint_results <- list(
      iteration = .GlobalEnv$iter_count,
      best_rmse = .GlobalEnv$best_rmse,
      best_params = .GlobalEnv$best_params,
      current_params = params_vector,
      current_rmse = rmse,
      rmse_history = .GlobalEnv$rmse_history,
      runtime_hours = difftime(Sys.time(), .GlobalEnv$start_time, units = "hours"),
      timestamp = Sys.time()
    )
    
    # Save with iteration number
    saveRDS(checkpoint_results,
            paste0("optimization_checkpoint_iter_", .GlobalEnv$iter_count, ".RDS"))
    
    # Also save as latest checkpoint for easy recovery
    saveRDS(checkpoint_results, "optimization_latest_checkpoint.RDS")
    
    cat("âœ“ Checkpoint saved at iteration", .GlobalEnv$iter_count,
        "| Best RMSE:", round(.GlobalEnv$best_rmse, 3), "\n")
  }
  
  # Periodic progress plot
  if (.GlobalEnv$iter_count %% plot_interval == 0) {
    plot_optimization_progress()
  }
  
  # Display current RMSE
  if (verbose || .GlobalEnv$iter_count %% 10 == 0) {
    cat("Iteration", .GlobalEnv$iter_count,
        "| Current RMSE:", round(rmse, 3),
        "| Best RMSE:", round(.GlobalEnv$best_rmse, 3), "\n")
  }
  
  return(rmse)
}

# Wrapper for calibrar
calibrar_objective_refined <- function(params_vector, ...) {
  rmse <- objective_function_refined(params_vector, ...)
  return(rmse)
}
```

# Run Refined Optimization

```{r run-optimization}
# Check for existing checkpoint to potentially resume
checkpoint_exists <- file.exists("optimization_latest_checkpoint.RDS")
if (checkpoint_exists) {
  cat("=== CHECKPOINT FOUND ===\n")
  last_checkpoint <- readRDS("optimization_latest_checkpoint.RDS")
  cat("Previous run stopped at iteration:", last_checkpoint$iteration, "\n")
  cat("Best RMSE achieved:", round(last_checkpoint$best_rmse, 3), "\n")
  cat("Runtime:", round(as.numeric(last_checkpoint$runtime_hours), 2), "hours\n\n")
  
  # Ask user if they want to resume
  cat("Do you want to resume from the best parameters found? (Recommended)\n")
  cat("If yes, update initial_params with: last_checkpoint$best_params\n\n")
  
  # Option to resume (uncomment to use):
  # initial_params <- last_checkpoint$best_params
  # .GlobalEnv$iter_count <- last_checkpoint$iteration
  # .GlobalEnv$best_rmse <- last_checkpoint$best_rmse
  # .GlobalEnv$best_params <- last_checkpoint$best_params
  # .GlobalEnv$rmse_history <- last_checkpoint$rmse_history
}

# Define species-specific weights
species_weights <- data.frame(
  Species = c("minke whales", "sperm whales", "baleen whales", "orca",
             "antarctic krill", "bathypelagic fishes", "shelf and coastal fishes",
             "squids", "toothfishes"),
  weight = c(5,      # minke whales - high priority
            10,     # sperm whales - highest priority (worst fit)
            8,      # baleen whales - very high priority
            3,      # orca - moderate priority
            1,      # krill - standard
            1,      # bathypelagic - standard
            1,      # shelf/coastal - standard
            1,      # squids - standard
            1)      # toothfish - standard
)

cat("=== SPECIES WEIGHTING STRATEGY ===\n")
print(species_weights)
cat("\n")

# Optimization method selection
optimization_method <- "SANN"  # Simulated Annealing for complex landscape

# Control parameters adapted for parallel/sequential processing
control_params <- if (use_parallel) {
  list(
    maxit = 1000,         # Fewer iterations due to parallel speedup
    factr = 1e7,          # Control precision
    pgtol = 1e-5,         # Gradient tolerance
    trace = 1,
    REPORT = 5            # More frequent reporting for parallel
  )
} else {
  list(
    maxit = 2000,         # More iterations for sequential SANN
    temp = 20,            # Higher initial temperature
    tmax = 20,            # Slower cooling
    trace = 1,
    REPORT = 10
  )
}

cat("=== OPTIMIZATION CONFIGURATION ===\n")
cat("Method:", optimization_method, "\n")
cat("Parallel processing:", ifelse(use_parallel, paste("YES (", n_cores, " cores)"), "NO"), "\n")
cat("Max iterations:", control_params$maxit, "\n")
cat("Burn-in years:", 300, "\n")
cat("Biomass tolerance:", 0.075, "\n")
cat("Steady-state tolerance:", 0.005, "\n")
cat("Reject unstable:", "YES\n")
cat("Checkpoint save interval: Every 50 iterations\n")
cat("Progress plot interval: Every 100 iterations\n\n")

# Estimated runtime with parallel considerations
est_time_per_iter <- ifelse(use_parallel, 35, 60)  # Parallel reduces per-iteration time
est_total_hours <- (control_params$maxit * est_time_per_iter) / 3600
parallel_speedup <- ifelse(use_parallel, min(n_cores * 0.7, 4), 1)  # 70% efficiency, max 4x
est_total_hours_adj <- est_total_hours / parallel_speedup

cat("Estimated runtime:", round(est_total_hours_adj, 1), "hours (",
    round(est_total_hours_adj/24, 1), "days)\n")
if (use_parallel) {
  cat("Expected speedup factor:", round(parallel_speedup, 1), "x\n")
  cat("Parallel efficiency: ~70%\n")
}
cat("\n")

# Export required objects to parallel workers if using parallel
if (use_parallel && exists("cl") && !is.null(cl)) {
  cat("Exporting objects to parallel workers...\n")
  
  # Export essential functions and data to cluster
  clusterExport(cl, c("params_fishing_only", "abundance_bounds", "catchability_bounds",
                     "gamma_bounds", "combined_effort_array", "yield_ts_tidy",
                     "species_weights", "apply_parameters_refined",
                     "run_with_enhanced_burnin", "check_biomass_stability_strict",
                     "objective_function_refined", "objective_function_parallel"),
               envir = environment())
  
  # Load required packages on workers
  clusterEvalQ(cl, {
    library(mizer)
    library(therMizer)
    library(dplyr)
    library(reshape2)
  })
  
  cat("Export complete. Workers ready for parallel optimization.\n\n")
}

# Verify parameter bounds
all_within_bounds <- all(initial_params >= lower_bounds) & all(initial_params <= upper_bounds)
if (!all_within_bounds) {
  cat("Adjusting parameters to be within bounds...\n")
  initial_params <- pmax(lower_bounds, pmin(upper_bounds, initial_params))
}

cat("Starting refined optimization with progress monitoring...\n")
cat("You can safely stop (Ctrl+C) and resume from checkpoints.\n")
cat("Best parameters are continuously saved to 'optimization_best_params.RDS'\n\n")

# Reset global tracking if starting fresh
if (!checkpoint_exists || .GlobalEnv$iter_count == 0) {
  .GlobalEnv$iter_count <- 0
  .GlobalEnv$best_rmse <- Inf
  .GlobalEnv$best_params <- NULL
  .GlobalEnv$rmse_history <- numeric()
  .GlobalEnv$start_time <- Sys.time()
}

# Run optimization with proper parallel/sequential handling
opt_result <- tryCatch({
  calibrate(
    par = initial_params,
    fn = calibrar_objective_refined,
    method = optimization_method,
    lower = lower_bounds,
    upper = upper_bounds,
    control = control_params,
    # Additional arguments
    base_params = params_base,
    abundance_bounds = abundance_bounds,
    catchability_bounds = catchability_bounds,
    gamma_bounds = gamma_bounds,
    effort_array = combined_effort_array,
    yield_obs_data = yield_ts_tidy,
    year_range = c(1961, 2010),
    burnin_years = 300,
    spinup_years = 118,
    t_start = 1841,
    sim_years = 170,
    species_weights = species_weights,
    reject_unstable = TRUE,
    biomass_tol = 0.075,
    save_interval = 50,   # Save checkpoint every 50 iterations
    plot_interval = 100,  # Plot progress every 100 iterations
    verbose = TRUE
  )
}, error = function(e) {
  cat("\n=== OPTIMIZATION INTERRUPTED OR FAILED ===\n")
  cat("Error message:", e$message, "\n")
  
  # Clean up parallel cluster if it exists
  if (use_parallel && exists("cl") && !is.null(cl)) {
    tryCatch({
      stopCluster(cl)
      registerDoSEQ()
      cat("Parallel cluster stopped due to error\n")
    }, error = function(e2) {
      cat("Warning: Could not stop cluster properly\n")
    })
  }
  
  # Check if we have any results to save
  if (exists(".GlobalEnv$iter_count") && .GlobalEnv$iter_count > 0) {
    cat("\nSaving results from", .GlobalEnv$iter_count, "iterations...\n")
    
    interrupted_results <- list(
      best_rmse = .GlobalEnv$best_rmse,
      best_params = .GlobalEnv$best_params,
      total_iterations = .GlobalEnv$iter_count,
      rmse_history = .GlobalEnv$rmse_history,
      runtime_hours = difftime(Sys.time(), .GlobalEnv$start_time, units = "hours"),
      status = "interrupted",
      error_message = e$message,
      parallel_used = use_parallel,
      timestamp = Sys.time()
    )
    
    saveRDS(interrupted_results, "optimization_interrupted_results.RDS")
    cat("Interrupted results saved to 'optimization_interrupted_results.RDS'\n")
    cat("Best parameters saved to 'optimization_best_params.RDS'\n")
    
    # Return partial results
    return(list(
      par = .GlobalEnv$best_params,
      value = .GlobalEnv$best_rmse,
      convergence = 1,  # Not converged
      counts = c(iterations = .GlobalEnv$iter_count),
      message = "Optimization interrupted but results saved"
    ))
  } else {
    stop("Optimization failed before completing any iterations")
  }
})

# Save final results
if (!is.null(opt_result)) {
  saveRDS(opt_result, "calibrar_optimization_refined_results.RDS")
  
  cat("\n=== OPTIMIZATION COMPLETE ===\n")
  cat("Total iterations:", .GlobalEnv$iter_count, "\n")
  cat("Final RMSE:", opt_result$value, "\n")
  cat("Best RMSE achieved:", .GlobalEnv$best_rmse, "\n")
  cat("Convergence:", opt_result$convergence, "\n")
  cat("Total runtime:", round(difftime(Sys.time(), .GlobalEnv$start_time, units = "hours"), 2), "hours\n")
  
  # Plot final progress
  plot_optimization_progress()
  
  # Save final configuration
  optimization_config <- list(
    method = optimization_method,
    species_weights = species_weights,
    burnin_years = 300,
    biomass_tolerance = 0.05,
    steady_state_tolerance = 0.0025,
    parameter_strategy = list(
      abundance_species = abundance_bounds$species,
      gamma_species = gamma_bounds$species,
      catchability_narrow = other_fished_species,
      catchability_wide = marine_mammal_species
    ),
    final_rmse = opt_result$value,
    best_rmse = .GlobalEnv$best_rmse,
    total_iterations = .GlobalEnv$iter_count,
    convergence = opt_result$convergence,
    runtime_hours = difftime(Sys.time(), .GlobalEnv$start_time, units = "hours"),
    date = Sys.Date()
  )
  
  saveRDS(optimization_config, "calibrar_optimization_refined_config.RDS")
}
```

# Run Optimal Simulation with Comprehensive Analysis

```{r analyze-optimal-results}
# Load optimization results if they exist
if (file.exists("optimization_best_params.RDS")) {
  cat("=== ANALYZING OPTIMAL PARAMETERS ===\n")
  
  # Load best parameters
  best_results <- readRDS("optimization_best_params.RDS")
  optimal_params <- best_results$best_params
  
  cat("Best RMSE found:", round(best_results$best_rmse, 4), "\n")
  cat("At iteration:", best_results$iteration, "\n\n")
  
  # Apply optimal parameters to create optimized model
  params_optimal <- apply_parameters_refined(optimal_params, params_fishing_only,
                                           abundance_bounds,
                                           catchability_bounds,
                                           gamma_bounds)
  
  # Run simulation with optimal parameters
  cat("Running simulation with optimal parameters...\n")
  sim_optimal <- run_with_enhanced_burnin(params_optimal, combined_effort_array,
                                         burnin_years = 300,
                                         spinup_years = 118,
                                         t_start = 1841,
                                         sim_years = 170,
                                         biomass_tol = 0.05,
                                         reject_unstable = FALSE)  # Don't reject for analysis
  
  # Save optimal simulation
  saveRDS(sim_optimal, "sim_optimal_calibrar_parallel.RDS")
  saveRDS(params_optimal, "params_optimal_calibrar_parallel.RDS")
  
  cat("Optimal simulation completed and saved\n\n")
  
  # Extract optimal parameter values for display
  n_abundance <- nrow(abundance_bounds)
  n_catchability <- nrow(catchability_bounds)
  n_gamma <- nrow(gamma_bounds)
  
  # Parse parameter values
  abundance_optimal <- exp(optimal_params[1:n_abundance])
  names(abundance_optimal) <- abundance_bounds$species
  
  catchability_optimal <- optimal_params[(n_abundance + 1):(n_abundance + n_catchability)]
  names(catchability_optimal) <- paste(catchability_bounds$species, catchability_bounds$gear, sep = "_")
  
  gamma_optimal <- exp(optimal_params[(n_abundance + n_catchability + 1):length(optimal_params)])
  names(gamma_optimal) <- gamma_bounds$species
  
  cat("=== OPTIMAL PARAMETER VALUES ===\n\n")
  cat("Marine Mammal Abundance Scaling Factors:\n")
  for (i in 1:length(abundance_optimal)) {
    cat(sprintf("  %s: %.2fx\n", names(abundance_optimal)[i], abundance_optimal[i]))
  }
  
  cat("\nOptimal Catchability Values:\n")
  for (i in 1:length(catchability_optimal)) {
    cat(sprintf("  %s: %.4f\n", names(catchability_optimal)[i], catchability_optimal[i]))
  }
  
  cat("\nOptimal Gamma (Search Rate) Values:\n")
  for (i in 1:length(gamma_optimal)) {
    cat(sprintf("  %s: %.2e\n", names(gamma_optimal)[i], gamma_optimal[i]))
  }
  
} else {
  cat("No optimization results found. Run optimization first.\n")
  sim_optimal <- NULL
}
```

# Generate Comprehensive Plots and Analysis

```{r comprehensive-analysis}
if (!is.null(sim_optimal)) {
  cat("\n=== GENERATING COMPREHENSIVE ANALYSIS PLOTS ===\n")
  
  # 1. Enhanced yield comparison plot
  p_yield_enhanced <- plot_yield_comparison_enhanced(
    sim_optimal,
    yield_ts_tidy,
    plot_title = "Optimal Model: Modeled vs. Observed Yield",
    filename = "optimal_yield_comparison_enhanced.png"
  )
  print(p_yield_enhanced)
  
  # 2. Biomass trajectory plot
  p_biomass_trajectories <- plot_biomass_trajectories(
    sim_optimal,
    plot_title = "Optimal Model: Biomass Trajectories",
    filename = "optimal_biomass_trajectories.png"
  )
  print(p_biomass_trajectories)
  
  # 3. Calculate detailed RMSE by species
  mod_yield <- getYield(sim_optimal)
  df_mod <- reshape2::melt(mod_yield)
  names(df_mod) <- c("Year", "Species", "Yield")
  
  # Filter to observation period
  df_mod_filtered <- df_mod[df_mod$Year >= 1961 & df_mod$Year <= 2010, ]
  yield_obs_filtered <- yield_ts_tidy[yield_ts_tidy$Year >= 1961 &
                                      yield_ts_tidy$Year <= 2010, ]
  
  # Calculate comprehensive RMSE statistics
  comparison <- merge(df_mod_filtered, yield_obs_filtered,
                     by = c("Year", "Species"),
                     suffixes = c("_mod", "_obs"))
  
  rmse_by_species <- comparison %>%
    group_by(Species) %>%
    summarise(
      RMSE = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)),
      MAE = mean(abs(Yield_mod - Yield_obs), na.rm = TRUE),
      Mean_Obs = mean(Yield_obs, na.rm = TRUE),
      Mean_Mod = mean(Yield_mod, na.rm = TRUE),
      Bias = mean(Yield_mod - Yield_obs, na.rm = TRUE),
      Relative_Error = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)) / mean(Yield_obs, na.rm = TRUE) * 100,
      Correlation = cor(Yield_mod, Yield_obs, use = "complete.obs"),
      n_obs = n(),
      .groups = 'drop'
    ) %>%
    arrange(RMSE)
  
  cat("\n=== DETAILED SPECIES-SPECIFIC PERFORMANCE ===\n")
  print(as.data.frame(rmse_by_species))
  
  # 4. Species-specific RMSE plot
  p_species_rmse <- plot_species_rmse(
    rmse_by_species,
    filename = "optimal_species_rmse.png"
  )
  print(p_species_rmse)
  
  # 5. Parameter evolution plot (if history available)
  if (exists(".GlobalEnv$rmse_history") && length(.GlobalEnv$rmse_history) > 1) {
    p_param_evolution <- plot_parameter_evolution(
      .GlobalEnv$rmse_history,
      filename = "optimization_parameter_evolution.png"
    )
    print(p_param_evolution)
  }
  
  # 6. Biomass stability analysis
  biomass_optimal <- getBiomass(sim_optimal)
  
  # Calculate coefficient of variation for last 50 years
  last_50_years <- tail(biomass_optimal, 50)
  cv_by_species <- apply(last_50_years, 2, function(x) sd(x) / mean(x) * 100)
  
  biomass_stats <- data.frame(
    Species = names(cv_by_species),
    CV_percent = round(cv_by_species, 2),
    Mean_Biomass = round(apply(last_50_years, 2, mean), 2),
    Final_Biomass = round(biomass_optimal[nrow(biomass_optimal), ], 2)
  ) %>%
    arrange(CV_percent)
  
  cat("\n=== BIOMASS STABILITY ANALYSIS (last 50 years) ===\n")
  print(biomass_stats)
  
  # 7. Create correlation matrix plot for yield fit
  correlation_matrix <- comparison %>%
    select(Species, Yield_mod, Yield_obs) %>%
    group_by(Species) %>%
    summarise(correlation = cor(Yield_mod, Yield_obs, use = "complete.obs")) %>%
    arrange(desc(correlation))
  
  # 8. Summary statistics plot
  p_summary <- ggplot(rmse_by_species, aes(x = reorder(Species, -Correlation), y = Correlation)) +
    geom_bar(stat = "identity", aes(fill = RMSE), alpha = 0.8) +
    coord_flip() +
    scale_fill_viridis_c(name = "RMSE", direction = -1) +
    theme_bw() +
    labs(title = "Model Performance Summary",
         subtitle = "Correlation with observations (colored by RMSE)",
         x = "Species",
         y = "Correlation") +
    theme(text = element_text(size = 12))
  
  print(p_summary)
  ggsave("plots/optimization_performance_summary.png", p_summary,
         width = 12, height = 8, dpi = 300)
  
  # 9. Save comprehensive results
  comprehensive_results <- list(
    optimal_parameters = list(
      abundance_scaling = abundance_optimal,
      catchability_values = catchability_optimal,
      gamma_values = gamma_optimal
    ),
    performance_metrics = rmse_by_species,
    biomass_stability = biomass_stats,
    correlation_matrix = correlation_matrix,
    optimization_summary = list(
      best_rmse = best_results$best_rmse,
      best_iteration = best_results$iteration,
      total_parameters = length(optimal_params),
      convergence_achieved = best_results$best_rmse < 1000  # Reasonable threshold
    ),
    timestamp = Sys.time()
  )
  
  saveRDS(comprehensive_results, "calibrar_comprehensive_analysis.RDS")
  
  cat("\n=== COMPREHENSIVE ANALYSIS COMPLETE ===\n")
  cat("Results saved to 'calibrar_comprehensive_analysis.RDS'\n")
  cat("All plots saved to 'plots/' directory\n\n")
  
} else {
  cat("Cannot perform analysis - no optimal simulation available\n")
}
```

# Performance Comparison and Recommendations

```{r performance-comparison}
if (!is.null(sim_optimal)) {
  cat("=== PERFORMANCE EVALUATION AND RECOMMENDATIONS ===\n\n")
  
  # Overall performance assessment
  overall_rmse <- sqrt(mean((comparison$Yield_mod - comparison$Yield_obs)^2, na.rm = TRUE))
  overall_correlation <- cor(comparison$Yield_mod, comparison$Yield_obs, use = "complete.obs")
  
  cat("OVERALL MODEL PERFORMANCE:\n")
  cat("  Overall RMSE:", round(overall_rmse, 3), "\n")
  cat("  Overall correlation:", round(overall_correlation, 3), "\n")
  cat("  Species with good fit (r > 0.7):", sum(rmse_by_species$Correlation > 0.7, na.rm = TRUE),
      "out of", nrow(rmse_by_species), "\n")
  cat("  Species with poor fit (r < 0.5):", sum(rmse_by_species$Correlation < 0.5, na.rm = TRUE),
      "out of", nrow(rmse_by_species), "\n\n")
  
  # Identify best and worst performing species
  best_species <- rmse_by_species %>%
    filter(Correlation > 0.7 & RMSE < quantile(rmse_by_species$RMSE, 0.5, na.rm = TRUE)) %>%
    arrange(RMSE) %>%
    head(3)
  
  worst_species <- rmse_by_species %>%
    filter(Correlation < 0.5 | RMSE > quantile(rmse_by_species$RMSE, 0.8, na.rm = TRUE)) %>%
    arrange(desc(RMSE)) %>%
    head(3)
  
  cat("BEST PERFORMING SPECIES:\n")
  for (i in 1:nrow(best_species)) {
    cat(sprintf("  %d. %s: RMSE = %.2f, r = %.3f\n",
                i, best_species$Species[i], best_species$RMSE[i], best_species$Correlation[i]))
  }
  
  cat("\nPOOREST PERFORMING SPECIES:\n")
  for (i in 1:nrow(worst_species)) {
    cat(sprintf("  %d. %s: RMSE = %.2f, r = %.3f\n",
                i, worst_species$Species[i], worst_species$RMSE[i], worst_species$Correlation[i]))
  }
  
  # Check biomass stability issues
  unstable_species <- biomass_stats$Species[biomass_stats$CV_percent > 20]
  
  cat("\nBIOMASS STABILITY ASSESSMENT:\n")
  if (length(unstable_species) > 0) {
    cat("  Species with high variability (CV > 20%):\n")
    for (sp in unstable_species) {
      cv_val <- biomass_stats$CV_percent[biomass_stats$Species == sp]
      cat(sprintf("    - %s: CV = %.1f%%\n", sp, cv_val))
    }
  } else {
    cat("  All species show acceptable biomass stability (CV < 20%)\n")
  }
  
  # Parameter assessment
  cat("\nPARAMETER ASSESSMENT:\n")
  cat("  Abundance scaling factors range:",
      round(min(abundance_optimal), 2), "to", round(max(abundance_optimal), 2), "\n")
  
  extreme_scaling <- names(abundance_optimal)[abundance_optimal > 50 | abundance_optimal < 0.5]
  if (length(extreme_scaling) > 0) {
    cat("  Species with extreme scaling (>50x or <0.5x):\n")
    for (sp in extreme_scaling) {
      cat(sprintf("    - %s: %.1fx\n", sp, abundance_optimal[sp]))
    }
  }
  
  # Recommendations
  cat("\nRECOMMENDATIONS:\n")
  
  if (overall_correlation > 0.8) {
    cat("  âœ“ Excellent overall model performance\n")
  } else if (overall_correlation > 0.6) {
    cat("  â‰ˆ Good overall model performance with room for improvement\n")
  } else {
    cat("  âœ— Model performance needs significant improvement\n")
  }
  
  if (length(worst_species$Species) > 0) {
    cat("\n  For poorly fitting species, consider:\n")
    cat("    - Reviewing data quality and completeness\n")
    cat("    - Adjusting species-specific parameters (growth rates, vulnerabilities)\n")
    cat("    - Including additional ecological processes\n")
    cat("    - Different functional group definitions\n")
  }
  
  if (length(unstable_species) > 0) {
    cat("\n  For biomass stability issues:\n")
    cat("    - Increase burn-in period beyond 300 years\n")
    cat("    - Tighten steady-state tolerance further\n")
    cat("    - Review predator-prey interaction strengths\n")
  }
  
  if (use_parallel) {
    cat("\n  Parallel processing performance:\n")
    if (exists("optimization_config")) {
      config <- readRDS("calibrar_optimization_refined_config.RDS")
      cat("    - Speedup achieved:", round(config$system_info$parallel_efficiency, 1), "x\n")
      cat("    - Cores used effectively:", config$cores_used, "out of", config$system_info$cores_available, "\n")
    }
  }
  
  cat("\n=== ANALYSIS COMPLETE ===\n")
  cat("Model is ready for scenario testing and projections\n\n")
}
```

# Recovery from Interruption

```{r recovery-setup, eval=FALSE}
# This chunk can be used to recover from an interrupted optimization

# Load the last checkpoint
if (file.exists("optimization_latest_checkpoint.RDS")) {
  last_checkpoint <- readRDS("optimization_latest_checkpoint.RDS")
  
  cat("=== RECOVERY FROM CHECKPOINT ===\n")
  cat("Last iteration:", last_checkpoint$iteration, "\n")
  cat("Best RMSE:", round(last_checkpoint$best_rmse, 3), "\n")
  cat("Runtime before interruption:", round(as.numeric(last_checkpoint$runtime_hours), 2), "hours\n\n")
  
  # Restore global variables
  .GlobalEnv$iter_count <- last_checkpoint$iteration
  .GlobalEnv$best_rmse <- last_checkpoint$best_rmse
  .GlobalEnv$best_params <- last_checkpoint$best_params
  .GlobalEnv$rmse_history <- last_checkpoint$rmse_history
  .GlobalEnv$start_time <- Sys.time() - as.difftime(last_checkpoint$runtime_hours, units = "hours")
  
  # Plot progress so far
  plot_optimization_progress()
  
  # Set initial parameters to best found so far
  initial_params <- last_checkpoint$best_params
  
  cat("\nReady to resume optimization from best parameters.\n")
  cat("Run the optimization chunk again to continue.\n")
} else if (file.exists("optimization_best_params.RDS")) {
  best_saved <- readRDS("optimization_best_params.RDS")
  
  cat("=== BEST PARAMETERS FOUND ===\n")
  cat("From iteration:", best_saved$iteration, "\n")
  cat("Best RMSE:", round(best_saved$best_rmse, 3), "\n")
  
  # Use best parameters as starting point
  initial_params <- best_saved$best_params
  
  cat("\nBest parameters loaded. Run optimization to continue improvement.\n")
} else {
  cat("No checkpoint or best parameters file found.\n")
  cat("Starting from scratch with initial parameters.\n")
}
```

# Summary

This refined optimization approach addresses the key issues identified:

1. **Parameter Selection**: Only marine mammals have abundance/gamma optimization
2. **Catchability**: Limited variation for species that already fit well
3. **Whale Prioritization**: 5-10x weighting for whale species
4. **Stability**: Stricter tolerance (0.05) and longer burn-in (300 years)
5. **Convergence**: More iterations and slower cooling for SANN

The optimization should now:
- Better fit whale yields (especially sperm and baleen)
- Maintain good fits for smaller species
- Produce more stable biomass trajectories
- Converge to a better solution


# Compare Optimal Simulation with Observations

```{r compare-results}

sim_optimal <- project(optimization_best_params, 
                       effort= combined_effort_array,
                       t_start = 1841,
                       t_max = 170)


# Plot yield comparison
species.labs <- c("Antarctic krill", "Bathypelagic fishes", "Shelf & Coastal fishes",
                  "Squids", "Toothfishes", "Antarctic minke whales", "Orcas",
                  "Sperm whales", "Baleen whales")
names(species.labs) <- c("antarctic krill", "bathypelagic fishes",
                         "shelf and coastal fishes", "squids", "toothfishes",
                         "minke whales", "orca", "sperm whales", "baleen whales")

# Get modeled yield data
mod_yield_data <- plotYieldGear(sim_optimal, return_data = TRUE)

p_yield_comparison <- ggplot() +
  # Model predictions
  geom_line(data = mod_yield_data,
            aes(x = Year, y = Yield, color = Species),
            size = 1.2) +
  # Observed data points
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield, color = Species),
             size = 2, alpha = 0.7) +
  facet_wrap(~Species, scales = "free_y",
             labeller = labeller(Species = species.labs)) +
  geom_vline(xintercept = c(1961, 2010), linetype = "dashed", alpha = 0.5) +
  theme_bw() +
  theme(legend.position = "none",
        strip.text = element_text(size = 10, face = "bold")) +
  labs(title = "Optimal Model Fit: Modeled vs. Observed Yield",
       subtitle = paste("Final RMSE =", round(opt_result$value, 3)),
       x = "Year",
       y = "Yield (tonnes)")

print(p_yield_comparison)
# ggsave("plots/calibrar_yield_comparison.png", p_yield_comparison,
#        width = 14, height = 10, dpi = 300)

# Calculate species-specific RMSE for the optimal simulation
mod_yield <- getYield(sim_optimal)
df_mod <- reshape2::melt(mod_yield)
names(df_mod) <- c("Year", "Species", "Yield")

# Filter to observation period
df_mod_filtered <- df_mod[df_mod$Year >= 1961 & df_mod$Year <= 2010, ]
yield_obs_filtered <- yield_ts_tidy[yield_ts_tidy$Year >= 1961 & 
                                    yield_ts_tidy$Year <= 2010, ]

# Merge and calculate RMSE by species
comparison <- merge(df_mod_filtered, yield_obs_filtered,
                   by = c("Year", "Species"),
                   suffixes = c("_mod", "_obs"))

rmse_by_species <- comparison %>%
  group_by(Species) %>%
  summarise(
    RMSE = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)),
    Mean_Obs = mean(Yield_obs, na.rm = TRUE),
    Mean_Mod = mean(Yield_mod, na.rm = TRUE),
    Relative_Error = RMSE / Mean_Obs * 100,
    n_obs = n()
  ) %>%
  arrange(RMSE)

cat("\n=== Species-specific RMSE (Optimal Model) ===\n")
print(as.data.frame(rmse_by_species))

# Plot species-specific RMSE
p_rmse_species <- ggplot(rmse_by_species, aes(x = reorder(Species, RMSE), y = RMSE)) +
  geom_bar(stat = "identity", fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  theme_bw() +
  labs(title = "Species-specific RMSE (Optimal Model)",
       x = "Species",
       y = "RMSE") +
  theme(text = element_text(size = 12))

print(p_rmse_species)
# ggsave("plots/calibrar_rmse_by_species.png", p_rmse_species,
#        width = 10, height = 6, dpi = 300)
```

# Biomass Stability Analysis

```{r biomass-stability}
# Check biomass stability over time
biomass_optimal <- getBiomass(sim_optimal)

# Calculate coefficient of variation for last 50 years
last_50_years <- tail(biomass_optimal, 50)
cv_by_species <- apply(last_50_years, 2, function(x) sd(x) / mean(x) * 100)

cat("\n=== Biomass Stability (CV% for last 50 years) ===\n")
cv_df <- data.frame(
  Species = names(cv_by_species),
  CV_percent = round(cv_by_species, 2)
) %>%
  arrange(CV_percent)

print(cv_df)

# Plot biomass time series
biomass_df <- reshape2::melt(biomass_optimal)
names(biomass_df) <- c("Year", "Species", "Biomass")

p_biomass <- ggplot(biomass_df, aes(x = Year, y = Biomass, color = Species)) +
  geom_line(size = 1) +
  facet_wrap(~Species, scales = "free_y") +
  theme_bw() +
  theme(legend.position = "none") +
  labs(title = "Biomass Trajectories (Optimal Model)",
       x = "Year",
       y = "Biomass") +
  geom_vline(xintercept = c(1961, 2010), linetype = "dashed", alpha = 0.5)

print(p_biomass)
# ggsave("plots/calibrar_biomass_trajectories.png", p_biomass,
#        width = 14, height = 10, dpi = 300)

# Check for biomass stability issues
unstable_species <- cv_df$Species[cv_df$CV_percent > 20]
if (length(unstable_species) > 0) {
  cat("\nWARNING: The following species show high biomass variability (CV > 20%):\n")
  cat(paste("  -", unstable_species, "\n"))
  cat("\nConsider increasing burn-in period or adjusting steady-state tolerance.\n")
}
```

