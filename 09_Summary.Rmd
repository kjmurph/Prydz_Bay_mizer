---
title: "R Notebook"
output: html_notebook
---

Do I need contant phytoplankton and temperature forcings for any spin-up, like if we need to use steady() in a loop testing parameter uncertaitny?

Also need to make sure initial effort is zero for the repreated forcing during a spin-up like above 

# Load helper functions

Some useful plotting functions for modelled versus observed yield (timeseries) and biomass (mean decadal value for 2010-2020)
```{r}
source("Helper_Functions.R")
```


# Load params
Best version of Pyrdz Bay mizer model parameters at steady-state for the contemporary ecosystem 2010 - 2020
```{r}
params_new_v4 <- readRDS("params_steady_state_2011_2020_tol_0.00025.RDS")
```

# Load climate forcings

The temperature and phytoplankton climate forcings for the ISIMIP3a protocol for Prydz Bay region
In some cases we need repeated constant values of the first year of these forcings, either for spin-ups or to mimin 'no climate change'. These repeated forcings are created as starting in 1961 and a version that starts in 1841

```{r}
# Temperature
extended_ocean_temp <- readRDS("temperature_forcing_1841_2010.rds")
constant_array_temp <- readRDS("constant_array_temp.RDS")
constant_array_temp_1841 <- readRDS("constant_array_temp_1841.RDS")

# Phytoplankton
extended_n_pp_array <- readRDS("phytoplankton_forcing_1841_2010.rds")
constant_array_n_pp <- readRDS("constant_array_n_pp.RDS")
constant_array_n_pp_1841 <- readRDS("constant_array_n_pp_1841.RDS")
```

# Setup params

```{r}
params_1841_2010_climate_only <- upgradeTherParams(params_new_v4, 
                                                   ocean_temp_array = extended_ocean_temp,
                                                   n_pp_array = extended_n_pp_array,
                                                   # vertical_migration_array = vertical_migration_array,
                                                   # exposure_array = ESS_exposure,
                                                   aerobic_effect = FALSE, metabolism_effect = TRUE)


params_1841_2010_fishing_only <- upgradeTherParams(params_new_v4, 
                                                   ocean_temp_array = constant_array_temp_1841,
                                                   n_pp_array = constant_array_n_pp_1841,
                                                   # vertical_migration_array = vertical_migration_array,
                                                   # exposure_array = ESS_exposure,
                                                   aerobic_effect = FALSE, metabolism_effect = TRUE)


```

# Run simulations

```{r}
sim_1841_2010_climate_only_spinup <- project(params_1841_2010_climate_only, 
                                             t_start = 1841, 
                                             t_max = 118,  
                                             effort = 0)
```


```{r}
sim_1841_2010_climate_only <- project(params_1841_2010_climate_only,
                                      initial_n=sim_1841_2010_climate_only_spinup@n[118,,], 
                                      t_start = 1841, 
                                      t_max = 170,  
                                      effort = 0)
```


```{r}
sim_1841_2010_fishing_only <- project(params_1841_2010_fishing_only,
                                      initial_n=sim_1841_2010_climate_only_spinup@n[118,,],
                                      t_start = 1841, 
                                      t_max = 170,  
                                      effort = combined_effort_array)
```


```{r}
sim_1841_2010_climate_and_fishing <- project(params_1841_2010_climate_only,
                                             initial_n=sim_1841_2010_climate_only_spinup@n[118,,],
                                             t_start = 1841, 
                                             t_max = 170,  
                                             effort = combined_effort_array)
```





# Size spectrum

```{r}
mizerExperimental::plotSpectra2(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1841:1860)
mizerExperimental::plotSpectra2(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1940:1950)
mizerExperimental::plotSpectra2(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 2000:2010)

plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1920:1930)
plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1930:1940)
plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1940:1950)
plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 2000:2010)
```


# Inspect biomass time series

```{r}
plot_biomass_comparison(sim_1841_2010_fishing_only)
```

# Inspect yield time series

```{r}
yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")

plot_yield_comparison(sim_1841_2010_fishing_only, 
                      yield_ts_tidy,
                      free_y_scale = F)
```


# Catchability uncertainty

Catchability for the fished groups is uncertain.
We want to explore the parameter space around catchability values for the fished groups to understand how that affects the modelled versus observed yield


```{r}
# Function to randomize catchability only for fished species
randomize_catchability <- function(params, sdev = 0.1) {
  # Get current gear parameters
  gear_df <- gear_params(params)
  
  # Check if there's fishing happening (non-zero catchability)
  if(nrow(gear_df) > 0) {
    # Generate noise for each catchability value
    for(i in 1:nrow(gear_df)) {
      # Only add noise if catchability is non-zero (meaning it's fished)
      if(gear_df$catchability[i] > 0) {
        # Generate random noise
        noise <- rnorm(1, mean = 0, sd = sdev)
        
        # Apply noise to catchability
        gear_df$catchability[i] <- gear_df$catchability[i] * exp(noise)
        
        # Ensure values stay between 0 and 1
        if(gear_df$catchability[i] > 1) gear_df$catchability[i] <- 1
        if(gear_df$catchability[i] < 0) gear_df$catchability[i] <- 0
      }
    }
    
    # Update parameters with new catchability values
    
    gear_params(params) <- gear_df
    
  }
  
  return(params)
}

# Function to run multiple simulations with randomized catchability for fished species
run_random_catchability_sims <- function(params, 
                                         n_sims = 10, 
                                         years = 170, 
                                         sd = 0.1, 
                                         effort_scen, 
                                         tol = .01,
                                         t_max = 500) {
  # List to store simulation results
  sim_results <- list()
  
  # Run simulations
  for(i in 1:n_sims) {
    # Create new parameters with randomized catchability
    rand_params <- randomize_catchability(params, sd = sd)
    
    # Run to steady state
    rand_params <- steady(rand_params, tol = tol, t_max = t_max)
    
    # Run simulation with provided effort scenario
    sim <- project(rand_params, effort = effort_scen)
    
    # Store results
    sim_results[[i]] <- sim
  }
  
  return(sim_results)
}
```


```{r}
#Orignal run
sim0 <- project(params_1841_2010_climate_only, effort = combined_effort_array)

plotlyBiomass(sim0)
plotYield(sim0)

# Run single simulation with randomized matrix as a test
rand_params <- randomize_catchability(params_1841_2010_climate_only)
sim1 <- project(rand_params,effort = combined_effort_array)

plotBiomassRelative(sim1,sim0)

# Run multiple simulations

# 9th July 2025 - try dramatically increasing the SD for catachability variation 
sims_scen4 <- run_random_catchability_sims(params_1841_2010_climate_only, n_sims = 100, effort_scen = combined_effort_array, sd = 2)



# Save sim outputs

saveRDS(sims_scen4,"sims_scen4.RDS")


# read in biomass and catches data

```


```{r}

# New facet label names for species
species.labs <- c("Antarctic krill", "Bathypelagic fishes", "Shelf & Coastal fishes", "Squids", "Toothfishes", "Antarctic minke whales", "Orcas", "Sperm whales", "Baleen whales")
names(species.labs) <- c("antarctic krill", "bathypelagic fishes", "shelf and coastal fishes", "squids", "toothfishes", "minke whales", "orca", "sperm whales", "baleen whales")

##############
# Figure for CATCHES 

trimYield<-function(sim){
  
  y<-plotYieldGear(sim, return_data = T)
  y<-select(y,c(Year, Species,Yield))
  return(y)
  
}

sim_catches<-lapply(sims_scen4,trimYield)
for (i in 1:100) {
  sim_catches[[i]]$sim<-i
}

df_sim_catch<-do.call(rbind.data.frame, sim_catches)

sim_mean_c<-df_sim_catch |>  group_by(Species,Year) |>summarise(Yield=median(Yield))|> ungroup()
sim_lower_c<-df_sim_catch |> group_by(Species,Year) |>summarise(Yield=min(Yield))|> ungroup() 
sim_upper_c<-df_sim_catch |> group_by(Species,Year)|>summarise(Yield=max(Yield))|> ungroup() 

sim1_c <-data.frame(Species=sim_mean_c$Species, 
                  Year=sim_mean_c$Year,
                  sim_mean=sim_mean_c$Yield,
                  sim_lower=sim_lower_c$Yield,
                  sim_upper=sim_upper_c$Yield)

sim1_c <-right_join(yield_ts,sim1_c)

# Plot

ggplot(sim1_c, aes(x=Year, y=Yield, colour=Species)) +
  facet_wrap(~Species, scales="free_y") +
  geom_point(aes(y=Yield), colour="black", size=0.5) +
  geom_ribbon(data = sim1_c, 
              aes(ymin=sim_lower, ymax=sim_upper), alpha=0.3, colour=NA) +
  geom_line(data = sim1_c, 
            aes(y=sim_mean,colour=Species)) +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.title.x = element_blank())

  p_yield <- plotYield(sim_1841_2010_fishing_only) + 
  facet_wrap(~Species,
             labeller = labeller(Species = species.labs)) +
  labs(fill = "Functional group") +
  # facet_wrap(~Species,scales="free_y") +
  geom_point(data = yield_ts_tidy, aes(x = Year, y = Yield, colour = Species), size=1) +
  geom_point(data = yield_ts_tidy, aes(x = Year, y = Yield), shape = 1,size = 1,colour = "black") +
  geom_ribbon(data = sim1_c, aes(x = Year, y=Yield, ymin=sim_lower, ymax=sim_upper), alpha=0.3, colour=NA) +
  theme(legend.title = element_text( size=3), legend.text=element_text(size=3)) + 
  geom_vline(aes(xintercept = 1961), linetype = "dashed") + 
  geom_vline(aes(xintercept = 2010), linetype = "dashed") +
  # scale_x_continuous(breaks = c(1930,1945,1961,1985,2010)) +
  # scale_y_log10() +
  theme_bw() +
  theme(
    legend.position = "none"
  )
  
p_yield

# ggsave("plots/Catchability_v1_Yield_1841_2010.tiff", plot = p_yield, units="cm", width=22, height=16, dpi =300)
```



# Scale initial abundances

We developed a steady-state model for the contemporary time period (2010-2020), but we are now assessing the historical change in biomass and yield. Thinking about the implication of historical whaling in particular, we need to explore how different initial steady-states would influence how biomass, yield and size structure change over time by exploring what initial conditions would need to be to best fit the yield timeseries and the mean value observed biomass for 2010-2020.

## Simple manual scaling example
Increase initial abundance of whales using the new helper functions
```{r}
# Setup base parameters with climate forcings
params_1841_2010_climate_only <- upgradeTherParams(params_new_v4,
                                                   ocean_temp_array = extended_ocean_temp,
                                                   n_pp_array = extended_n_pp_array,
                                                   # vertical_migration_array = vertical_migration_array,
                                                   # exposure_array = ESS_exposure,
                                                   aerobic_effect = FALSE, metabolism_effect = TRUE)

# Use the new scaling function for marine mammals
# Scaling factors: minke whales (50x), orca (5x), sperm whales (50x), baleen whales (50x)
scaling_factors <- c(50, 5, 50, 50)
marine_mammal_species <- c("minke whales", "orca", "sperm whales", "baleen whales")

params_scaled_v1 <- scale_marine_mammal_abundance(params_1841_2010_climate_only,
                                                  scaling_factors = scaling_factors,
                                                  species_to_scale = marine_mammal_species)

# Run to steady state
params_scaled_v1 <- steady(params_scaled_v1,
                           t_max = 500,
                           tol = 0.01,
                           preserve = c("erepro"))

species_params(params_scaled_v1)$erepro
plot(params_scaled_v1)
```

```{r}
sim_scaled_spinup <- project(params_scaled_v1, 
                             t_start = 1841,
                             t_max = 118,
                             effort = 0)
```

```{r}
sim_scaled_climate_only <- project(params_scaled_v1,
                                      initial_n=sim_scaled_spinup@n[118,,], 
                                      t_start = 1841, 
                                      t_max = 170,  
                                      effort = 0)
```

```{r}
sim_scaled_climate_and_fishing <- project(params_scaled_v1,
                                             initial_n=sim_scaled_spinup@n[118,,],
                                             t_start = 1841, 
                                             t_max = 170,  
                                             effort = combined_effort_array)
```

# Inspect biomass time series

```{r}
plot_biomass_comparison(sim_scaled_climate_only)
plot_biomass_comparison(sim_scaled_climate_and_fishing)
```
# Combined Catchability and Abundance Scaling Uncertainty Assessment

This section implements a comprehensive uncertainty assessment that combines both catchability uncertainty for fished species and abundance scaling uncertainty for marine mammals. This approach allows us to explore the parameter space more thoroughly and find optimal parameter combinations that best match observed data.

## Setup for Combined Uncertainty Analysis

```{r combined-uncertainty-setup}
# Load required libraries for parallel processing
library(parallel)
library(doParallel)
library(foreach)

# Function to run a single simulation with randomized parameters
run_single_sim <- function(sim_id, params, catchability_sd, abundance_sd,
                          marine_mammal_species, effort_scen, tol, t_max,
                          spinup_years, t_start, sim_years,
                          preserve_erepro, max_erepro) {
  
  # Create copy of params
  rand_params <- params
  
  # Step 1: Randomize catchability for fished species
  gear_df <- gear_params(rand_params)
  original_catchability <- gear_df$catchability
  
  if(nrow(gear_df) > 0) {
    for(j in 1:nrow(gear_df)) {
      if(gear_df$catchability[j] > 0) {
        # Generate log-normal noise for catchability
        noise <- rnorm(1, mean = 0, sd = catchability_sd)
        gear_df$catchability[j] <- gear_df$catchability[j] * exp(noise)
        # Ensure values stay between 0 and 1
        gear_df$catchability[j] <- min(1, max(0, gear_df$catchability[j]))
      }
    }
    gear_params(rand_params) <- gear_df
  }
  
  # Step 2: Randomize marine mammal abundance
  # Get species indices for marine mammals
  sp_params <- species_params(rand_params)
  species_indices <- which(sp_params$species %in% marine_mammal_species)
  
  # Generate random scaling factors (log-normal distribution)
  scaling_factors <- exp(rnorm(length(species_indices), mean = 0, sd = abundance_sd))
  
  # Apply scaling to initial abundance
  for (k in seq_along(species_indices)) {
    rand_params@initial_n[species_indices[k],] <-
      rand_params@initial_n[species_indices[k],] * scaling_factors[k]
  }
  
  # Step 3: Run to steady state with randomized parameters
  if (preserve_erepro) {
    # Preserve erepro values during steady state
    rand_params <- steady(rand_params, tol = tol, t_max = t_max, preserve = c("erepro"))
  } else {
    # Don't preserve erepro
    rand_params <- steady(rand_params, tol = tol, t_max = t_max)
    
    # Check if any species require erepro > max_erepro
    current_erepro <- species_params(rand_params)$erepro
    if (any(current_erepro > max_erepro, na.rm = TRUE)) {
      # Return NULL to indicate this simulation should be skipped
      return(list(
        success = FALSE,
        skipped_info = list(
          sim_id = sim_id,
          erepro_values = current_erepro,
          species_over_limit = sp_params$species[which(current_erepro > max_erepro)],
          catchability = gear_df$catchability,
          marine_mammal_scaling = scaling_factors
        )
      ))
    }
  }
  
  # Step 4: Run spinup if specified
  if (spinup_years > 0) {
    sim_spinup <- project(rand_params,
                         t_start = t_start,
                         t_max = spinup_years,
                         effort = 0)
    
    # Run main simulation with spinup initial conditions
    sim <- project(rand_params,
                  initial_n = sim_spinup@n[spinup_years,,],
                  t_start = t_start,
                  t_max = sim_years,
                  effort = effort_scen)
  } else {
    # Run simulation without spinup
    sim <- project(rand_params,
                  t_start = t_start,
                  t_max = sim_years,
                  effort = effort_scen)
  }
  
  # Return successful result
  return(list(
    success = TRUE,
    sim_id = sim_id,
    simulation = sim,
    params_info = list(
      sim_id = sim_id,
      catchability = gear_df$catchability,
      catchability_change = gear_df$catchability / original_catchability,
      marine_mammal_scaling = scaling_factors,
      marine_mammal_species = marine_mammal_species[seq_along(scaling_factors)],
      erepro_values = species_params(rand_params)$erepro
    )
  ))
}

# Main function to run simulations with combined uncertainty (with parallel processing)
run_combined_uncertainty_sims <- function(params,
                                         n_sims = 10,
                                         catchability_sd = 0.1,
                                         abundance_sd = 0.2,
                                         marine_mammal_species = NULL,
                                         effort_scen,
                                         tol = 0.01,
                                         t_max = 500,
                                         spinup_years = 118,
                                         t_start = 1841,
                                         sim_years = 170,
                                         preserve_erepro = TRUE,
                                         max_erepro = 1,
                                         n_cores = NULL,
                                         parallel = TRUE) {
  
  # Default marine mammal species if not specified
  if (is.null(marine_mammal_species)) {
    marine_mammal_species <- c("minke whales", "orca", "sperm whales", "baleen whales")
  }
  
  # Determine number of cores to use
  if (is.null(n_cores)) {
    n_cores <- detectCores() - 1  # Leave one core free
  }
  n_cores <- min(n_cores, detectCores())
  
  # Progress message
  cat("Running", n_sims, "simulations with combined uncertainty...\n")
  if (preserve_erepro) {
    cat("  Preserving erepro values during steady state\n")
  } else {
    cat("  Not preserving erepro; will skip simulations with erepro >", max_erepro, "\n")
  }
  
  if (parallel && n_cores > 1) {
    cat("  Using parallel processing with", n_cores, "cores\n")
    
    # Set up parallel cluster
    cl <- makeCluster(n_cores)
    registerDoParallel(cl)
    
    # Export necessary objects to cluster
    clusterExport(cl, c("run_single_sim"), envir = environment())
    
    # Run simulations in parallel
    # We'll run extra simulations to account for potential skips
    n_attempts <- ifelse(preserve_erepro, n_sims, ceiling(n_sims * 1.5))
    
    cat("  Running", n_attempts, "initial attempts...\n")
    
    results <- foreach(i = 1:n_attempts,
                      .packages = c("mizer", "therMizer"),
                      .errorhandling = "pass") %dopar% {
      run_single_sim(i, params, catchability_sd, abundance_sd,
                    marine_mammal_species, effort_scen, tol, t_max,
                    spinup_years, t_start, sim_years,
                    preserve_erepro, max_erepro)
    }
    
    # Stop cluster
    stopCluster(cl)
    
  } else {
    # Sequential processing
    cat("  Using sequential processing\n")
    
    n_attempts <- ifelse(preserve_erepro, n_sims, ceiling(n_sims * 1.5))
    results <- list()
    
    for(i in 1:n_attempts) {
      if(i %% 10 == 0) cat("  Processing simulation", i, "of", n_attempts, "\n")
      
      results[[i]] <- run_single_sim(i, params, catchability_sd, abundance_sd,
                                    marine_mammal_species, effort_scen, tol, t_max,
                                    spinup_years, t_start, sim_years,
                                    preserve_erepro, max_erepro)
    }
  }
  
  # Process results
  sim_results <- list()
  param_combinations <- list()
  skipped_sims <- list()
  successful_count <- 0
  
  for(res in results) {
    if(!is.null(res) && !inherits(res, "error")) {
      if(res$success) {
        successful_count <- successful_count + 1
        if(successful_count <= n_sims) {
          sim_results[[successful_count]] <- res$simulation
          param_combinations[[successful_count]] <- res$params_info
        }
      } else {
        skipped_sims[[length(skipped_sims) + 1]] <- res$skipped_info
      }
    }
  }
  
  # If we don't have enough successful simulations, run more
  while(successful_count < n_sims && length(results) < n_sims * 3) {
    cat("  Need", n_sims - successful_count, "more successful simulations...\n")
    
    additional_attempts <- n_sims - successful_count + ceiling((n_sims - successful_count) * 0.5)
    
    if (parallel && n_cores > 1) {
      cl <- makeCluster(n_cores)
      registerDoParallel(cl)
      clusterExport(cl, c("run_single_sim"), envir = environment())
      
      additional_results <- foreach(i = (length(results) + 1):(length(results) + additional_attempts),
                                   .packages = c("mizer", "therMizer"),
                                   .errorhandling = "pass") %dopar% {
        run_single_sim(i, params, catchability_sd, abundance_sd,
                      marine_mammal_species, effort_scen, tol, t_max,
                      spinup_years, t_start, sim_years,
                      preserve_erepro, max_erepro)
      }
      
      stopCluster(cl)
    } else {
      additional_results <- list()
      for(i in 1:additional_attempts) {
        additional_results[[i]] <- run_single_sim(length(results) + i, params,
                                                 catchability_sd, abundance_sd,
                                                 marine_mammal_species, effort_scen,
                                                 tol, t_max, spinup_years, t_start,
                                                 sim_years, preserve_erepro, max_erepro)
      }
    }
    
    # Process additional results
    for(res in additional_results) {
      if(!is.null(res) && !inherits(res, "error")) {
        if(res$success) {
          successful_count <- successful_count + 1
          if(successful_count <= n_sims) {
            sim_results[[successful_count]] <- res$simulation
            param_combinations[[successful_count]] <- res$params_info
          }
        } else {
          skipped_sims[[length(skipped_sims) + 1]] <- res$skipped_info
        }
      }
    }
    
    results <- c(results, additional_results)
  }
  
  # Final summary
  cat("\nCompleted", min(successful_count, n_sims), "successful simulations\n")
  if (length(skipped_sims) > 0) {
    cat("Skipped", length(skipped_sims), "simulations due to erepro >", max_erepro, "\n")
    
    # Summarize which species caused skips
    all_species_over <- unlist(lapply(skipped_sims, function(x) x$species_over_limit))
    if(length(all_species_over) > 0) {
      species_skip_counts <- table(all_species_over)
      cat("\nSpecies causing skips:\n")
      print(species_skip_counts)
    }
  }
  
  # Trim to requested number of simulations
  if(length(sim_results) > n_sims) {
    sim_results <- sim_results[1:n_sims]
    param_combinations <- param_combinations[1:n_sims]
  }
  
  return(list(
    simulations = sim_results,
    parameters = param_combinations,
    skipped = skipped_sims,
    n_successful = length(sim_results),
    n_attempts = length(results)
  ))
}

# Function to calculate RMSE between modeled and observed yield
calculate_yield_rmse <- function(sim_object,
                                yield_obs_data,
                                species_list = NULL,
                                year_range = NULL) {
  
  # Get modeled yield
  mod_yield <- getYield(sim_object)
  
  # Convert to data frame
  df_mod <- reshape2::melt(mod_yield)
  names(df_mod) <- c("Year", "Species", "Yield")
  
  # Filter by year range if specified
  if (!is.null(year_range)) {
    df_mod <- df_mod[df_mod$Year >= min(year_range) & df_mod$Year <= max(year_range), ]
    yield_obs_data <- yield_obs_data[yield_obs_data$Year >= min(year_range) &
                                     yield_obs_data$Year <= max(year_range), ]
  }
  
  # Filter by species if specified
  if (!is.null(species_list)) {
    df_mod <- df_mod[df_mod$Species %in% species_list, ]
    yield_obs_data <- yield_obs_data[yield_obs_data$Species %in% species_list, ]
  }
  
  # Merge modeled and observed data
  comparison <- merge(df_mod, yield_obs_data,
                     by = c("Year", "Species"),
                     suffixes = c("_mod", "_obs"))
  
  # Calculate RMSE
  rmse <- sqrt(mean((comparison$Yield_mod - comparison$Yield_obs)^2, na.rm = TRUE))
  
  # Also calculate RMSE by species
  rmse_by_species <- comparison %>%
    group_by(Species) %>%
    summarise(
      RMSE = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)),
      n_obs = n()
    )
  
  return(list(
    total_rmse = rmse,
    rmse_by_species = rmse_by_species,
    comparison_data = comparison
  ))
}

# Function to find optimal parameter combination based on RMSE
find_optimal_parameters <- function(sim_results_list,
                                   yield_obs_data,
                                   species_list = NULL,
                                   year_range = NULL) {
  
  # Calculate RMSE for each simulation
  n_sims <- length(sim_results_list$simulations)
  rmse_values <- numeric(n_sims)
  rmse_details <- list()
  
  cat("Calculating RMSE for each simulation...\n")
  
  for(i in seq_along(sim_results_list$simulations)) {
    rmse_result <- calculate_yield_rmse(sim_results_list$simulations[[i]],
                                       yield_obs_data,
                                       species_list = species_list,
                                       year_range = year_range)
    rmse_values[i] <- rmse_result$total_rmse
    rmse_details[[i]] <- rmse_result
  }
  
  # Find optimal (minimum RMSE)
  optimal_idx <- which.min(rmse_values)
  
  # Create summary statistics
  rmse_stats <- data.frame(
    mean = mean(rmse_values),
    median = median(rmse_values),
    sd = sd(rmse_values),
    min = min(rmse_values),
    max = max(rmse_values),
    q25 = quantile(rmse_values, 0.25),
    q75 = quantile(rmse_values, 0.75)
  )
  
  cat("RMSE Statistics:\n")
  print(rmse_stats)
  cat("\nOptimal simulation:", optimal_idx, "with RMSE =", rmse_values[optimal_idx], "\n")
  
  return(list(
    optimal_index = optimal_idx,
    optimal_rmse = rmse_values[optimal_idx],
    optimal_sim = sim_results_list$simulations[[optimal_idx]],
    optimal_params = sim_results_list$parameters[[optimal_idx]],
    all_rmse = rmse_values,
    rmse_details = rmse_details,
    rmse_stats = rmse_stats
  ))
}

# Function to plot RMSE distribution from uncertainty analysis
plot_rmse_distribution <- function(rmse_values,
                                  optimal_idx = NULL,
                                  plot_title = "RMSE Distribution from Combined Parameter Uncertainty") {
  
  require(ggplot2)
  
  df <- data.frame(
    Simulation = 1:length(rmse_values),
    RMSE = rmse_values
  )
  
  # Calculate statistics for annotation
  mean_rmse <- mean(rmse_values)
  median_rmse <- median(rmse_values)
  
  p <- ggplot(df, aes(x = RMSE)) +
    geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "black") +
    theme_bw() +
    labs(
      title = plot_title,
      subtitle = paste("n =", length(rmse_values), "simulations"),
      x = "RMSE (Root Mean Square Error)",
      y = "Frequency"
    ) +
    # Add mean line
    geom_vline(xintercept = mean_rmse,
              color = "blue", linetype = "dotted", linewidth = 1) +
    # Add median line
    geom_vline(xintercept = median_rmse,
              color = "green", linetype = "dotted", linewidth = 1)
  
  # Add vertical line for optimal value if provided
  if (!is.null(optimal_idx)) {
    p <- p +
      geom_vline(xintercept = rmse_values[optimal_idx],
                color = "red", linetype = "dashed", linewidth = 1) +
      annotate("text",
              x = rmse_values[optimal_idx],
              y = max(table(cut(rmse_values, 30))) * 0.9,
              label = paste("Optimal RMSE =", round(rmse_values[optimal_idx], 2)),
              hjust = -0.1, color = "red")
  }
  
  # Add legend for lines
  p <- p +
    annotate("text", x = mean_rmse, y = max(table(cut(rmse_values, 30))) * 0.8,
            label = paste("Mean =", round(mean_rmse, 2)),
            hjust = -0.1, color = "blue", size = 3) +
    annotate("text", x = median_rmse, y = max(table(cut(rmse_values, 30))) * 0.7,
            label = paste("Median =", round(median_rmse, 2)),
            hjust = -0.1, color = "green", size = 3)
  
  return(p)
}

# Function to visualize parameter combinations
plot_parameter_exploration <- function(param_combinations, rmse_values) {
  
  require(ggplot2)
  require(tidyr)
  require(dplyr)
  
  # Extract catchability and marine mammal scaling
  df_params <- data.frame(
    sim_id = 1:length(param_combinations),
    rmse = rmse_values
  )
  
  # Add catchability info (assuming single gear for simplicity)
  df_params$catchability <- sapply(param_combinations, function(x) mean(x$catchability))
  
  # Add marine mammal scaling (mean across all marine mammals)
  df_params$mammal_scaling <- sapply(param_combinations, function(x) mean(x$marine_mammal_scaling))
  
  # Create scatter plot
  p1 <- ggplot(df_params, aes(x = catchability, y = mammal_scaling, color = rmse)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_gradient(low = "blue", high = "red", name = "RMSE") +
    theme_bw() +
    labs(
      title = "Parameter Space Exploration",
      x = "Mean Catchability",
      y = "Mean Marine Mammal Scaling Factor"
    )
  
  # Create individual parameter distributions
  p2 <- ggplot(df_params, aes(x = catchability)) +
    geom_histogram(bins = 20, fill = "steelblue", alpha = 0.7) +
    theme_bw() +
    labs(title = "Catchability Distribution", x = "Catchability", y = "Count")
  
  p3 <- ggplot(df_params, aes(x = mammal_scaling)) +
    geom_histogram(bins = 20, fill = "darkgreen", alpha = 0.7) +
    theme_bw() +
    labs(title = "Marine Mammal Scaling Distribution", x = "Scaling Factor", y = "Count")
  
  # Combine plots
  require(gridExtra)
  combined_plot <- grid.arrange(p1, p2, p3, ncol = 2, nrow = 2)
  
  return(combined_plot)
}
```

## Run Combined Uncertainty Analysis

Now we'll run the combined uncertainty analysis with both catchability and abundance scaling uncertainty:

```{r run-combined-uncertainty, eval=FALSE}
# Load required data if not already loaded
if (!exists("combined_effort_array")) {
  combined_effort_array <- readRDS("effort_array_1841_2010.rds")
}

if (!exists("yield_ts_tidy")) {
  yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")
}

# Run combined uncertainty simulations
# Using moderate uncertainty for both parameters
combined_uncertainty_results <- run_combined_uncertainty_sims(
  params = params_1841_2010_fishing_only,
  n_sims = 100,  # Number of simulations (can be thousands with parallel processing)
  catchability_sd = 0.2,  # 20% CV for catchability
  abundance_sd = 0.3,  # 30% CV for marine mammal abundance
  marine_mammal_species = c("minke whales", "orca", "sperm whales", "baleen whales"),
  effort_scen = combined_effort_array,
  tol = 0.01,
  t_max = 500,
  spinup_years = 118,
  t_start = 1841,
  sim_years = 170,
  preserve_erepro = TRUE,  # Set to FALSE to filter out simulations with erepro > 1
  max_erepro = 1,  # Maximum allowed erepro when preserve_erepro = FALSE
  n_cores = NULL,  # NULL = use all available cores minus 1
  parallel = TRUE  # Set to FALSE for sequential processing
)

# Example for running thousands of simulations in parallel
# combined_uncertainty_results_large <- run_combined_uncertainty_sims(
#   params = params_1841_2010_fishing_only,
#   n_sims = 1000,  # Run 1000 simulations
#   catchability_sd = 0.2,
#   abundance_sd = 0.3,
#   marine_mammal_species = c("minke whales", "orca", "sperm whales", "baleen whales"),
#   effort_scen = combined_effort_array,
#   tol = 0.01,
#   t_max = 500,
#   spinup_years = 118,
#   t_start = 1841,
#   sim_years = 170,
#   preserve_erepro = TRUE,
#   max_erepro = 1,
#   n_cores = 8,  # Use 8 cores
#   parallel = TRUE
# )

# Display summary of results
cat("\n=== Simulation Summary ===\n")
cat("Successful simulations:", combined_uncertainty_results$n_successful, "\n")
cat("Total attempts:", combined_uncertainty_results$n_attempts, "\n")
if (length(combined_uncertainty_results$skipped) > 0) {
  cat("Skipped simulations:", length(combined_uncertainty_results$skipped), "\n")
}

# Save results
saveRDS(combined_uncertainty_results, "combined_uncertainty_results.RDS")
```

## Analyze Results and Find Optimal Parameters

```{r analyze-combined-results, eval=FALSE}
# Find optimal parameters based on RMSE
optimal_results <- find_optimal_parameters(
  sim_results_list = combined_uncertainty_results,
  yield_obs_data = yield_ts_tidy,
  species_list = c("antarctic krill", "bathypelagic fishes",
                   "shelf and coastal fishes", "squids", "toothfishes",
                   "minke whales", "orca", "sperm whales", "baleen whales"),
  year_range = c(1961, 2010)  # Focus on period with observed data
)

# Save optimal results
saveRDS(optimal_results, "optimal_parameter_results.RDS")

# Display optimal parameters
cat("\n=== Optimal Parameter Combination ===\n")
cat("Simulation ID:", optimal_results$optimal_index, "\n")
cat("RMSE:", optimal_results$optimal_rmse, "\n")
cat("\nCatchability values:\n")
print(optimal_results$optimal_params$catchability)
cat("\nMarine mammal scaling factors:\n")
print(data.frame(
  Species = optimal_results$optimal_params$marine_mammal_species,
  Scaling = optimal_results$optimal_params$marine_mammal_scaling
))
```

## Visualize Uncertainty Analysis Results

```{r visualize-combined-results, eval=FALSE}
# Plot RMSE distribution
p_rmse_dist <- plot_rmse_distribution(
  rmse_values = optimal_results$all_rmse,
  optimal_idx = optimal_results$optimal_index,
  plot_title = "RMSE Distribution from Combined Catchability & Abundance Uncertainty"
)
print(p_rmse_dist)
ggsave("plots/combined_uncertainty_rmse_distribution.png", p_rmse_dist,
       width = 10, height = 6, dpi = 300)

# Plot parameter exploration
p_param_explore <- plot_parameter_exploration(
  param_combinations = combined_uncertainty_results$parameters,
  rmse_values = optimal_results$all_rmse
)
ggsave("plots/combined_parameter_exploration.png", p_param_explore,
       width = 12, height = 10, dpi = 300)
```

## Compare Optimal Simulation with Observations

```{r compare-optimal-simulation, eval=FALSE}
# First, run the original model with params_new_v4 for comparison
sim_original <- project(params_new_v4, effort = combined_effort_array)

# Extract uncertainty bounds from all simulations
# For yield uncertainty bounds
yield_uncertainty_data <- do.call(rbind, lapply(seq_along(combined_uncertainty_results$simulations), function(i) {
  sim <- combined_uncertainty_results$simulations[[i]]
  yield_data <- plotYieldGear(sim, return_data = TRUE)
  yield_data$sim_id <- i
  return(select(yield_data, Year, Species, Yield, sim_id))
}))

# Calculate uncertainty bounds for yield
yield_bounds <- yield_uncertainty_data %>%
  group_by(Year, Species) %>%
  summarise(
    yield_lower = quantile(Yield, 0.025, na.rm = TRUE),
    yield_upper = quantile(Yield, 0.975, na.rm = TRUE),
    yield_median = median(Yield, na.rm = TRUE),
    .groups = 'drop'
  )

# For biomass uncertainty bounds
biomass_uncertainty_data <- do.call(rbind, lapply(seq_along(combined_uncertainty_results$simulations), function(i) {
  sim <- combined_uncertainty_results$simulations[[i]]
  biomass_matrix <- getBiomass(sim)
  biomass_data <- reshape2::melt(biomass_matrix)
  names(biomass_data) <- c("Year", "Species", "Biomass")
  biomass_data$sim_id <- i
  return(biomass_data)
}))

# Calculate uncertainty bounds for biomass
biomass_bounds <- biomass_uncertainty_data %>%
  group_by(Year, Species) %>%
  summarise(
    biomass_lower = quantile(Biomass, 0.025, na.rm = TRUE),
    biomass_upper = quantile(Biomass, 0.975, na.rm = TRUE),
    biomass_median = median(Biomass, na.rm = TRUE),
    .groups = 'drop'
  )

# Species labels for faceting
species.labs <- c("Antarctic krill", "Bathypelagic fishes", "Shelf & Coastal fishes",
                  "Squids", "Toothfishes", "Antarctic minke whales", "Orcas",
                  "Sperm whales", "Baleen whales")
names(species.labs) <- c("antarctic krill", "bathypelagic fishes",
                         "shelf and coastal fishes", "squids", "toothfishes",
                         "minke whales", "orca", "sperm whales", "baleen whales")

# Plot yield comparison for optimal simulation with uncertainty bounds
p_yield_optimal <- plotYield(optimal_results$optimal_sim) +
  facet_wrap(~Species, scales = "free_y",
             labeller = labeller(Species = species.labs)) +
  # Add uncertainty ribbon
  geom_ribbon(data = yield_bounds,
              aes(x = Year, ymin = yield_lower, ymax = yield_upper),
              alpha = 0.3, fill = "lightblue", inherit.aes = FALSE) +
  # Add original model fit line
  geom_line(data = plotYieldGear(sim_original, return_data = TRUE),
            aes(x = Year, y = Yield),
            color = "darkgray", linetype = "dashed", linewidth = 1, inherit.aes = FALSE) +
  # Add best fit model line (solid black)
  geom_line(data = plotYieldGear(optimal_results$optimal_sim, return_data = TRUE),
            aes(x = Year, y = Yield),
            color = "black", linetype = "solid", linewidth = 1.2, inherit.aes = FALSE) +
  # Add observed data points
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield, colour = Species),
             size = 1, inherit.aes = FALSE) +
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield),
             shape = 1, size = 1, colour = "black", inherit.aes = FALSE) +
  # Add vertical reference lines
  geom_vline(aes(xintercept = 1961), linetype = "dotted", alpha = 0.7) +
  geom_vline(aes(xintercept = 2010), linetype = "dotted", alpha = 0.7) +
  theme_bw() +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 10)
  ) +
  labs(
    title = "Optimal Simulation: Modeled vs. Observed Yield with Uncertainty",
    subtitle = "Gray dashed = original model, Black solid = best fit, Blue ribbon = 95% CI",
    x = "Year",
    y = "Yield"
  )

print(p_yield_optimal)
ggsave("plots/optimal_simulation_yield.png", p_yield_optimal,
       width = 14, height = 10, dpi = 300)

# Get original model biomass data
original_biomass_matrix <- getBiomass(sim_original)
original_biomass_data <- reshape2::melt(original_biomass_matrix)
names(original_biomass_data) <- c("Year", "Species", "Biomass")

# Get optimal model biomass data
optimal_biomass_matrix <- getBiomass(optimal_results$optimal_sim)
optimal_biomass_data <- reshape2::melt(optimal_biomass_matrix)
names(optimal_biomass_data) <- c("Year", "Species", "Biomass")

# Plot biomass comparison for optimal simulation with uncertainty bounds
p_biomass_optimal <- plot_biomass_comparison(
  sim_object = optimal_results$optimal_sim,
  plot_title = "Optimal Simulation: Modeled vs. Observed Biomass with Uncertainty"
) +
  # Add uncertainty ribbon
  geom_ribbon(data = biomass_bounds,
              aes(x = Year, ymin = biomass_lower, ymax = biomass_upper),
              alpha = 0.3, fill = "lightcoral", inherit.aes = FALSE) +
  # Add original model fit line
  geom_line(data = original_biomass_data,
            aes(x = Year, y = Biomass),
            color = "darkgray", linetype = "dashed", linewidth = 1, inherit.aes = FALSE) +
  # Add best fit model line (solid black)
  geom_line(data = optimal_biomass_data,
            aes(x = Year, y = Biomass),
            color = "black", linetype = "solid", linewidth = 1.2, inherit.aes = FALSE) +
  labs(
    subtitle = "Gray dashed = original model, Black solid = best fit, Coral ribbon = 95% CI"
  )

print(p_biomass_optimal)
ggsave("plots/optimal_simulation_biomass.png", p_biomass_optimal,
       width = 14, height = 10, dpi = 300)
```

## Summary Statistics and Sensitivity Analysis

```{r sensitivity-analysis, eval=FALSE}
# Create summary table of RMSE by species
rmse_by_species_summary <- do.call(rbind, lapply(optimal_results$rmse_details,
                                                 function(x) x$rmse_by_species))
rmse_by_species_summary$sim_id <- rep(1:length(optimal_results$rmse_details),
                                      each = length(unique(rmse_by_species_summary$Species)))

# Calculate statistics by species
species_rmse_stats <- rmse_by_species_summary %>%
  group_by(Species) %>%
  summarise(
    mean_rmse = mean(RMSE, na.rm = TRUE),
    median_rmse = median(RMSE, na.rm = TRUE),
    sd_rmse = sd(RMSE, na.rm = TRUE),
    min_rmse = min(RMSE, na.rm = TRUE),
    max_rmse = max(RMSE, na.rm = TRUE)
  ) %>%
  arrange(mean_rmse)

cat("\n=== RMSE Statistics by Species ===\n")
print(species_rmse_stats)

# Plot species-specific RMSE distributions
p_species_rmse <- ggplot(rmse_by_species_summary, aes(x = Species, y = RMSE)) +
  geom_boxplot(fill = "lightblue", alpha = 0.7) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "RMSE Distribution by Species",
    subtitle = "From combined uncertainty analysis",
    x = "Species",
    y = "RMSE"
  )
print(p_species_rmse)
ggsave("plots/rmse_by_species_boxplot.png", p_species_rmse,
       width = 12, height = 6, dpi = 300)

# Calculate correlation between parameters and RMSE
param_rmse_correlation <- data.frame(
  catchability = sapply(combined_uncertainty_results$parameters,
                       function(x) mean(x$catchability)),
  mammal_scaling = sapply(combined_uncertainty_results$parameters,
                         function(x) mean(x$marine_mammal_scaling)),
  rmse = optimal_results$all_rmse
)

cor_matrix <- cor(param_rmse_correlation)
cat("\n=== Parameter-RMSE Correlations ===\n")
print(cor_matrix)

# Create a heatmap of correlations
require(corrplot)
png("plots/parameter_rmse_correlation.png", width = 800, height = 600)
corrplot(cor_matrix, method = "color", type = "upper",
         addCoef.col = "black", tl.col = "black", tl.srt = 45,
         title = "Parameter-RMSE Correlations")
dev.off()
```

## Export Optimal Parameters for Future Use

```{r export-optimal-params, eval=FALSE}
# Extract optimal parameters for future simulations
optimal_params_export <- params_1841_2010_fishing_only

# Update with optimal catchability
gear_df <- gear_params(optimal_params_export)
gear_df$catchability <- optimal_results$optimal_params$catchability
gear_params(optimal_params_export) <- gear_df

# Update with optimal marine mammal scaling
sp_params <- species_params(optimal_params_export)
mammal_indices <- which(sp_params$species %in% optimal_results$optimal_params$marine_mammal_species)
for (i in seq_along(mammal_indices)) {
  optimal_params_export@initial_n[mammal_indices[i],] <-
    optimal_params_export@initial_n[mammal_indices[i],] *
    optimal_results$optimal_params$marine_mammal_scaling[i]
}

# Run to steady state (preserving erepro if needed)
# Check if we want to preserve erepro based on the original analysis
preserve_erepro_export <- TRUE  # Set this based on your preference
if (preserve_erepro_export) {
  optimal_params_export <- steady(optimal_params_export, tol = 0.01, t_max = 500, preserve = c("erepro"))
} else {
  optimal_params_export <- steady(optimal_params_export, tol = 0.01, t_max = 500)
  # Check final erepro values
  final_erepro <- species_params(optimal_params_export)$erepro
  if (any(final_erepro > 1, na.rm = TRUE)) {
    warning("Some species have erepro > 1 in the optimal parameters:")
    print(data.frame(
      Species = sp_params$species[which(final_erepro > 1)],
      erepro = final_erepro[which(final_erepro > 1)]
    ))
  }
}

# Save optimal parameters
saveRDS(optimal_params_export, "params_optimal_combined_uncertainty.RDS")

cat("\nOptimal parameters saved to 'params_optimal_combined_uncertainty.RDS'\n")
```
## Adaptive Uncertainty Analysis with Species-Specific Refinement

This section implements an improved adaptive approach that checks RMSE every 10 simulations and refines the parameter search space based on performance, with special attention to species with poor fits.

### Run Adaptive Uncertainty Analysis

The adaptive approach gradually refines the search space, focusing on parameter combinations that show promise while specifically tracking species that have poor fits (like Antarctic krill and minke whales). All necessary functions are included in Helper_Functions.R.

```{r run-adaptive-analysis, eval=FALSE}
# Load required data if not already loaded
if (!exists("combined_effort_array")) {
  combined_effort_array <- readRDS("effort_array_1841_2010.rds")
}

if (!exists("yield_ts_tidy")) {
  yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")
}

# Run adaptive uncertainty analysis
# This will check RMSE every 10 simulations and refine the search space
adaptive_results <- run_adaptive_uncertainty_analysis(
  params = params_1841_2010_fishing_only,
  n_total_sims = 500,  # Total number of simulations
  check_interval = 10,  # Check and refine every 10 simulations (more frequent updates)
  initial_catchability_sd = 0.3,  # Start with wider search
  initial_abundance_sd = 0.4,  # Start with wider search
  marine_mammal_species = c("minke whales", "orca", "sperm whales", "baleen whales"),
  fished_species = c("antarctic krill", "bathypelagic fishes",
                    "shelf and coastal fishes", "squids", "toothfishes",
                    "minke whales", "orca", "sperm whales", "baleen whales"),
  effort_scen = combined_effort_array,
  yield_obs_data = yield_ts_tidy,
  year_range = c(1961, 2010),
  tol = 0.01,
  t_max = 500,
  spinup_years = 118,
  t_start = 1841,
  sim_years = 170,
  preserve_erepro = TRUE,
  max_erepro = 1,
  convergence_threshold = 0.01,  # Stop refining if improvement < 1%
  n_cores = NULL,  # Use all available cores minus 1
  parallel = TRUE,
  verbose = TRUE  # Show progress and species-specific issues
)

# Save adaptive results
saveRDS(adaptive_results, "adaptive_uncertainty_results.RDS")

# Display summary
cat("\n=== Adaptive Analysis Summary ===\n")
cat("Total simulations:", adaptive_results$optimal$total_simulations, "\n")
cat("Optimal RMSE:", round(adaptive_results$optimal$optimal_rmse, 3), "\n")
cat("RMSE range:", round(range(adaptive_results$all_rmse), 3), "\n")

# Display runtime information
cat("\n=== Runtime Information ===\n")
cat("Total runtime:", round(adaptive_results$optimal$runtime$total_minutes, 1), "minutes\n")
cat("Average time per simulation:", round(adaptive_results$optimal$runtime$avg_time_per_simulation, 1), "seconds\n")
cat("Parallel processing:", ifelse(adaptive_results$optimal$runtime$parallel_used,
                                  paste("YES (", adaptive_results$optimal$runtime$n_cores_used, " cores)", sep=""),
                                  "NO (sequential)"), "\n")

cat("\nSpecies-specific RMSE (best simulation):\n")
best_species_rmse <- adaptive_results$species_rmse[[adaptive_results$optimal$optimal_index]]
for (sp in names(best_species_rmse)) {
  cat("  ", sp, ":", round(best_species_rmse[[sp]], 3), "\n")
}
```

### Visualize Adaptive Convergence

```{r visualize-adaptive-convergence, eval=FALSE}
# Plot convergence history
p_convergence <- plot_adaptive_convergence(adaptive_results)
ggsave("plots/adaptive_convergence_history.png", p_convergence,
       width = 12, height = 14, dpi = 300)

# Plot species-specific RMSE evolution
# Focus on problematic species
p_species_evolution <- plot_species_rmse_evolution(
  adaptive_results,
  species_focus = c("antarctic_krill", "minke_whales", "baleen_whales", "sperm_whales")
)
print(p_species_evolution)
ggsave("plots/species_rmse_evolution.png", p_species_evolution,
       width = 14, height = 10, dpi = 300)

# Plot all species RMSE evolution
p_all_species <- plot_species_rmse_evolution(adaptive_results)
ggsave("plots/all_species_rmse_evolution.png", p_all_species,
       width = 16, height = 12, dpi = 300)
```

### Analyze Parameter Correlations

```{r analyze-adaptive-parameters, eval=FALSE}
# Create correlation heatmap for top performers
cor_matrix <- plot_parameter_correlations(adaptive_results, top_percent = 0.1)

# Extract optimal parameters
optimal_params_adaptive <- adaptive_results$optimal$optimal_parameters
cat("\n=== Optimal Parameters from Adaptive Search ===\n")
cat("Catchability values:\n")
print(optimal_params_adaptive$catchability)
cat("\nMarine mammal scaling factors:\n")
mm_scaling_df <- data.frame(
  Species = optimal_params_adaptive$marine_mammal_species,
  Scaling = optimal_params_adaptive$marine_mammal_scaling
)
print(mm_scaling_df)

# Compare with initial parameters
cat("\n=== Parameter Changes from Initial ===\n")
cat("Catchability changes:\n")
print(optimal_params_adaptive$catchability_change)
```

### Compare Adaptive vs. Standard Approach

```{r compare-approaches, eval=FALSE}
# Load standard approach results if available
if (file.exists("combined_uncertainty_results.RDS")) {
  standard_results <- readRDS("combined_uncertainty_results.RDS")
  
  # Compare RMSE distributions
  df_comparison <- data.frame(
    RMSE = c(adaptive_results$all_rmse,
             sapply(standard_results$simulations, function(sim) {
               calculate_yield_rmse(sim, yield_ts_tidy,
                                  species_list = c("antarctic krill", "bathypelagic fishes",
                                                  "shelf and coastal fishes", "squids", "toothfishes",
                                                  "minke whales", "orca", "sperm whales", "baleen whales"),
                                  year_range = c(1961, 2010))$total_rmse
             })),
    Method = c(rep("Adaptive", length(adaptive_results$all_rmse)),
              rep("Standard", length(standard_results$simulations)))
  )
  
  p_comparison <- ggplot(df_comparison, aes(x = Method, y = RMSE, fill = Method)) +
    geom_boxplot(alpha = 0.7) +
    geom_point(position = position_jitter(width = 0.2), alpha = 0.3) +
    scale_fill_manual(values = c("Adaptive" = "darkgreen", "Standard" = "steelblue")) +
    theme_bw() +
    labs(title = "RMSE Comparison: Adaptive vs. Standard Uncertainty Analysis",
         subtitle = "Adaptive approach refines search space every 50 simulations",
         y = "RMSE") +
    theme(legend.position = "none")
  
  print(p_comparison)
  ggsave("plots/adaptive_vs_standard_comparison.png", p_comparison,
         width = 8, height = 6, dpi = 300)
  
  # Statistical comparison
  cat("\n=== Statistical Comparison ===\n")
  cat("Adaptive - Min RMSE:", round(min(adaptive_results$all_rmse), 3), "\n")
  cat("Standard - Min RMSE:", round(min(df_comparison$RMSE[df_comparison$Method == "Standard"]), 3), "\n")
  cat("Improvement:",
      round((min(df_comparison$RMSE[df_comparison$Method == "Standard"]) -
             min(adaptive_results$all_rmse)) /
            min(df_comparison$RMSE[df_comparison$Method == "Standard"]) * 100, 1), "%\n")
  
  # Compare runtimes if available
  if (!is.null(adaptive_results$optimal$runtime)) {
    cat("\n=== Runtime Comparison ===\n")
    cat("Adaptive approach runtime:", round(adaptive_results$optimal$runtime$total_minutes, 1), "minutes\n")
    cat("Time per simulation:", round(adaptive_results$optimal$runtime$avg_time_per_simulation, 1), "seconds\n")
    cat("Efficiency note: Adaptive approach focuses computational effort on promising regions\n")
  }
}
```

### Apply Optimal Parameters from Adaptive Search

```{r apply-adaptive-optimal, eval=FALSE}
# Extract and apply optimal parameters
optimal_sim_adaptive <- adaptive_results$optimal$optimal_simulation

# Plot yield comparison with observations
p_yield_adaptive <- plotYield(optimal_sim_adaptive) +
  facet_wrap(~Species, scales = "free_y") +
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield, colour = Species),
             size = 1) +
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield),
             shape = 1, size = 1, colour = "black") +
  geom_vline(aes(xintercept = 1961), linetype = "dotted", alpha = 0.7) +
  geom_vline(aes(xintercept = 2010), linetype = "dotted", alpha = 0.7) +
  theme_bw() +
  theme(legend.position = "none") +
  labs(title = "Optimal Simulation from Adaptive Search",
       subtitle = paste("RMSE =", round(adaptive_results$optimal$optimal_rmse, 3)))

print(p_yield_adaptive)
ggsave("plots/adaptive_optimal_yield.png", p_yield_adaptive,
       width = 14, height = 10, dpi = 300)

# Create detailed species-specific comparison plots
species_focus <- c("antarctic krill", "minke whales")
for (sp in species_focus) {
  # Get modeled yield for this species
  mod_yield <- getYield(optimal_sim_adaptive)
  df_mod <- reshape2::melt(mod_yield)
  names(df_mod) <- c("Year", "Species", "Yield")
  df_mod_sp <- df_mod[df_mod$Species == sp, ]
  
  # Get observed yield for this species
  obs_sp <- yield_ts_tidy[yield_ts_tidy$Species == sp, ]
  
  p_sp <- ggplot() +
    geom_line(data = df_mod_sp, aes(x = Year, y = Yield),
              color = "darkblue", size = 1.2) +
    geom_point(data = obs_sp, aes(x = Year, y = Yield),
               color = "red", size = 2) +
    theme_bw() +
    labs(title = paste("Adaptive Optimization Result:", sp),
         subtitle = paste("RMSE =", round(best_species_rmse[[sp]], 3)),
         x = "Year", y = "Yield") +
    geom_vline(xintercept = c(1961, 2010), linetype = "dotted", alpha = 0.5)
  
  print(p_sp)
  ggsave(paste0("plots/adaptive_", gsub(" ", "_", sp), "_comparison.png"),
         p_sp, width = 10, height = 6, dpi = 300)
}
```

### Export Optimal Parameters for Future Use

```{r export-adaptive-optimal, eval=FALSE}
# Create parameter object with optimal values
params_optimal_adaptive <- params_1841_2010_fishing_only

# Apply optimal catchability
gear_df <- gear_params(params_optimal_adaptive)
gear_df$catchability <- optimal_params_adaptive$catchability
gear_params(params_optimal_adaptive) <- gear_df

# Apply optimal marine mammal scaling
sp_params <- species_params(params_optimal_adaptive)
mammal_indices <- which(sp_params$species %in% optimal_params_adaptive$marine_mammal_species)
for (i in seq_along(mammal_indices)) {
  params_optimal_adaptive@initial_n[mammal_indices[i],] <-
    params_optimal_adaptive@initial_n[mammal_indices[i],] *
    optimal_params_adaptive$marine_mammal_scaling[i]
}

# Run to steady state
params_optimal_adaptive <- steady(params_optimal_adaptive,
                                 tol = 0.01,
                                 t_max = 500,
                                 preserve = c("erepro"))

# Save optimal parameters
saveRDS(params_optimal_adaptive, "params_optimal_adaptive.RDS")
cat("\nOptimal parameters from adaptive search saved to 'params_optimal_adaptive.RDS'\n")
```

## Conclusions

This enhanced adaptive uncertainty assessment provides several key improvements:

1. **Adaptive Parameter Refinement**: The search space is refined every 50 simulations based on performance, allowing the algorithm to focus on promising parameter regions
2. **Species-Specific Tracking**: Individual species RMSE is monitored throughout, identifying problematic species (like Antarctic krill and minke whales) that need special attention
3. **Convergence Monitoring**: The algorithm tracks convergence and can automatically reduce search space when improvements plateau
4. **Efficient Search**: By gradually narrowing the search space, the adaptive approach finds better solutions with fewer simulations
5. **Targeted Optimization**: The algorithm biases search towards regions that show promise, improving efficiency

The adaptive approach specifically addresses the issue of species with poor fits by:
- Tracking their individual RMSE throughout the optimization
- Identifying when certain species consistently have high errors
- Adjusting the search strategy to improve these specific fits
- Providing detailed diagnostics about which species are problematic

This method is particularly effective for complex models where different species may require different scaling factors or catchability adjustments to match observed data.


