---
title: "R Notebook"
output: html_notebook
---

Do I need contant phytoplankton and temperature forcings for any spin-up, like if we need to use steady() in a loop testing parameter uncertaitny?

Also need to make sure initial effort is zero for the repreated forcing during a spin-up like above 

# Load helper functions

Some useful plotting functions for modelled versus observed yield (timeseries) and biomass (mean decadal value for 2010-2020)
```{r}
source("Helper_Functions.R")
```


```{r}
library(therMizer)
library(mizer)
library(tidyverse)
```


# Load params
Best version of Pyrdz Bay mizer model parameters at steady-state for the contemporary ecosystem 2010 - 2020
```{r}
params_new_v4 <- readRDS("params_steady_state_2011_2020_tol_0.00025.RDS")
```

# Load climate forcings

The temperature and phytoplankton climate forcings for the ISIMIP3a protocol for Prydz Bay region
In some cases we need repeated constant values of the first year of these forcings, either for spin-ups or to mimin 'no climate change'. These repeated forcings are created as starting in 1961 and a version that starts in 1841

```{r}
# Temperature
extended_ocean_temp <- readRDS("temperature_forcing_1841_2010.rds")
constant_array_temp <- readRDS("constant_array_temp.RDS")
constant_array_temp_1841 <- readRDS("constant_array_temp_1841.RDS")

# Phytoplankton
extended_n_pp_array <- readRDS("phytoplankton_forcing_1841_2010.rds")
constant_array_n_pp <- readRDS("constant_array_n_pp.RDS")
constant_array_n_pp_1841 <- readRDS("constant_array_n_pp_1841.RDS")
```

# Setup params

```{r}
params_1841_2010_climate_only <- upgradeTherParams(params_new_v4, 
                                                   ocean_temp_array = extended_ocean_temp,
                                                   n_pp_array = extended_n_pp_array,
                                                   # vertical_migration_array = vertical_migration_array,
                                                   # exposure_array = ESS_exposure,
                                                   aerobic_effect = FALSE, metabolism_effect = TRUE)


params_1841_2010_fishing_only <- upgradeTherParams(params_new_v4, 
                                                   ocean_temp_array = constant_array_temp_1841,
                                                   n_pp_array = constant_array_n_pp_1841,
                                                   # vertical_migration_array = vertical_migration_array,
                                                   # exposure_array = ESS_exposure,
                                                   aerobic_effect = FALSE, metabolism_effect = TRUE)


```

# Run simulations

```{r}
sim_1841_2010_climate_only_spinup <- project(params_1841_2010_climate_only, 
                                             t_start = 1841, 
                                             t_max = 118,  
                                             effort = 0)
```


```{r}
sim_1841_2010_climate_only <- project(params_1841_2010_climate_only,
                                      initial_n=sim_1841_2010_climate_only_spinup@n[118,,], 
                                      t_start = 1841, 
                                      t_max = 170,  
                                      effort = 0)
```


```{r}
sim_1841_2010_fishing_only <- project(params_1841_2010_fishing_only,
                                      initial_n=sim_1841_2010_climate_only_spinup@n[118,,],
                                      t_start = 1841, 
                                      t_max = 170,  
                                      effort = combined_effort_array)
```


```{r}
sim_1841_2010_climate_and_fishing <- project(params_1841_2010_climate_only,
                                             initial_n=sim_1841_2010_climate_only_spinup@n[118,,],
                                             t_start = 1841, 
                                             t_max = 170,  
                                             effort = combined_effort_array)
```





# Size spectrum

```{r}
mizerExperimental::plotSpectra2(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1841:1860)
mizerExperimental::plotSpectra2(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1940:1950)
mizerExperimental::plotSpectra2(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 2000:2010)

plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1920:1930)
plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1930:1940)
plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1940:1950)
plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 2000:2010)
```


# Inspect biomass time series

```{r}
plot_biomass_comparison(sim_1841_2010_fishing_only)
```

# Inspect yield time series

```{r}
yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")

plot_yield_comparison(sim_1841_2010_fishing_only, 
                      yield_ts_tidy,
                      free_y_scale = F)
```


# Catchability uncertainty

Catchability for the fished groups is uncertain.
We want to explore the parameter space around catchability values for the fished groups to understand how that affects the modelled versus observed yield


```{r}
# Function to randomize catchability only for fished species
randomize_catchability <- function(params, sdev = 0.1) {
  # Get current gear parameters
  gear_df <- gear_params(params)
  
  # Check if there's fishing happening (non-zero catchability)
  if(nrow(gear_df) > 0) {
    # Generate noise for each catchability value
    for(i in 1:nrow(gear_df)) {
      # Only add noise if catchability is non-zero (meaning it's fished)
      if(gear_df$catchability[i] > 0) {
        # Generate random noise
        noise <- rnorm(1, mean = 0, sd = sdev)
        
        # Apply noise to catchability
        gear_df$catchability[i] <- gear_df$catchability[i] * exp(noise)
        
        # Ensure values stay between 0 and 1
        if(gear_df$catchability[i] > 1) gear_df$catchability[i] <- 1
        if(gear_df$catchability[i] < 0) gear_df$catchability[i] <- 0
      }
    }
    
    # Update parameters with new catchability values
    
    gear_params(params) <- gear_df
    
  }
  
  return(params)
}

# Function to run multiple simulations with randomized catchability for fished species
run_random_catchability_sims <- function(params, 
                                         n_sims = 10, 
                                         years = 170, 
                                         sd = 0.1, 
                                         effort_scen, 
                                         tol = .01,
                                         t_max = 500) {
  # List to store simulation results
  sim_results <- list()
  
  # Run simulations
  for(i in 1:n_sims) {
    # Create new parameters with randomized catchability
    rand_params <- randomize_catchability(params, sd = sd)
    
    # Run to steady state
    rand_params <- steady(rand_params, tol = tol, t_max = t_max)
    
    # Run simulation with provided effort scenario
    sim <- project(rand_params, effort = effort_scen)
    
    # Store results
    sim_results[[i]] <- sim
  }
  
  return(sim_results)
}
```


```{r}
#Orignal run
sim0 <- project(params_1841_2010_climate_only, effort = combined_effort_array)

plotlyBiomass(sim0)
plotYield(sim0)

# Run single simulation with randomized matrix as a test
rand_params <- randomize_catchability(params_1841_2010_climate_only)
sim1 <- project(rand_params,effort = combined_effort_array)

plotBiomassRelative(sim1,sim0)

# Run multiple simulations

# 9th July 2025 - try dramatically increasing the SD for catachability variation 
sims_scen4 <- run_random_catchability_sims(params_1841_2010_climate_only, n_sims = 100, effort_scen = combined_effort_array, sd = 2)



# Save sim outputs

saveRDS(sims_scen4,"sims_scen4.RDS")


# read in biomass and catches data

```


```{r}

# New facet label names for species
species.labs <- c("Antarctic krill", "Bathypelagic fishes", "Shelf & Coastal fishes", "Squids", "Toothfishes", "Antarctic minke whales", "Orcas", "Sperm whales", "Baleen whales")
names(species.labs) <- c("antarctic krill", "bathypelagic fishes", "shelf and coastal fishes", "squids", "toothfishes", "minke whales", "orca", "sperm whales", "baleen whales")

##############
# Figure for CATCHES 

trimYield<-function(sim){
  
  y<-plotYieldGear(sim, return_data = T)
  y<-select(y,c(Year, Species,Yield))
  return(y)
  
}

sim_catches<-lapply(sims_scen4,trimYield)
for (i in 1:100) {
  sim_catches[[i]]$sim<-i
}

df_sim_catch<-do.call(rbind.data.frame, sim_catches)

sim_mean_c<-df_sim_catch |>  group_by(Species,Year) |>summarise(Yield=median(Yield))|> ungroup()
sim_lower_c<-df_sim_catch |> group_by(Species,Year) |>summarise(Yield=min(Yield))|> ungroup() 
sim_upper_c<-df_sim_catch |> group_by(Species,Year)|>summarise(Yield=max(Yield))|> ungroup() 

sim1_c <-data.frame(Species=sim_mean_c$Species, 
                  Year=sim_mean_c$Year,
                  sim_mean=sim_mean_c$Yield,
                  sim_lower=sim_lower_c$Yield,
                  sim_upper=sim_upper_c$Yield)

sim1_c <-right_join(yield_ts,sim1_c)

# Plot

ggplot(sim1_c, aes(x=Year, y=Yield, colour=Species)) +
  facet_wrap(~Species, scales="free_y") +
  geom_point(aes(y=Yield), colour="black", size=0.5) +
  geom_ribbon(data = sim1_c, 
              aes(ymin=sim_lower, ymax=sim_upper), alpha=0.3, colour=NA) +
  geom_line(data = sim1_c, 
            aes(y=sim_mean,colour=Species)) +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.title.x = element_blank())

  p_yield <- plotYield(sim_1841_2010_fishing_only) + 
  facet_wrap(~Species,
             labeller = labeller(Species = species.labs)) +
  labs(fill = "Functional group") +
  # facet_wrap(~Species,scales="free_y") +
  geom_point(data = yield_ts_tidy, aes(x = Year, y = Yield, colour = Species), size=1) +
  geom_point(data = yield_ts_tidy, aes(x = Year, y = Yield), shape = 1,size = 1,colour = "black") +
  geom_ribbon(data = sim1_c, aes(x = Year, y=Yield, ymin=sim_lower, ymax=sim_upper), alpha=0.3, colour=NA) +
  theme(legend.title = element_text( size=3), legend.text=element_text(size=3)) + 
  geom_vline(aes(xintercept = 1961), linetype = "dashed") + 
  geom_vline(aes(xintercept = 2010), linetype = "dashed") +
  # scale_x_continuous(breaks = c(1930,1945,1961,1985,2010)) +
  # scale_y_log10() +
  theme_bw() +
  theme(
    legend.position = "none"
  )
  
p_yield

# ggsave("plots/Catchability_v1_Yield_1841_2010.tiff", plot = p_yield, units="cm", width=22, height=16, dpi =300)
```



# Scale initial abundances

We developed a steady-state model for the contemporary time period (2010-2020), but we are now assessing the historical change in biomass and yield. Thinking about the implication of historical whaling in particular, we need to explore how different initial steady-states would influence how biomass, yield and size structure change over time by exploring what initial conditions would need to be to best fit the yield timeseries and the mean value observed biomass for 2010-2020.

## Simple manual scaling example
Increase initial abundance of whales using the new helper functions
```{r}
# Setup base parameters with climate forcings
params_1841_2010_climate_only <- upgradeTherParams(params_new_v4,
                                                   ocean_temp_array = extended_ocean_temp,
                                                   n_pp_array = extended_n_pp_array,
                                                   # vertical_migration_array = vertical_migration_array,
                                                   # exposure_array = ESS_exposure,
                                                   aerobic_effect = FALSE, metabolism_effect = TRUE)

# Use the new scaling function for marine mammals
# Scaling factors: minke whales (50x), orca (5x), sperm whales (50x), baleen whales (50x)
scaling_factors <- c(50, 5, 50, 50)
marine_mammal_species <- c("minke whales", "orca", "sperm whales", "baleen whales")

params_scaled_v1 <- scale_marine_mammal_abundance(params_1841_2010_climate_only,
                                                  scaling_factors = scaling_factors,
                                                  species_to_scale = marine_mammal_species)

# Run to steady state
params_scaled_v1 <- steady(params_scaled_v1,
                           t_max = 500,
                           tol = 0.01,
                           preserve = c("erepro"))

species_params(params_scaled_v1)$erepro
plot(params_scaled_v1)
```

```{r}
sim_scaled_spinup <- project(params_scaled_v1, 
                             t_start = 1841,
                             t_max = 118,
                             effort = 0)
```

```{r}
sim_scaled_climate_only <- project(params_scaled_v1,
                                      initial_n=sim_scaled_spinup@n[118,,], 
                                      t_start = 1841, 
                                      t_max = 170,  
                                      effort = 0)
```

```{r}
sim_scaled_climate_and_fishing <- project(params_scaled_v1,
                                             initial_n=sim_scaled_spinup@n[118,,],
                                             t_start = 1841, 
                                             t_max = 170,  
                                             effort = combined_effort_array)
```

# Inspect biomass time series

```{r}
plot_biomass_comparison(sim_scaled_climate_only)
plot_biomass_comparison(sim_scaled_climate_and_fishing)
```
# Combined Catchability and Abundance Scaling Uncertainty Assessment

This section implements a comprehensive uncertainty assessment that combines both catchability uncertainty for fished species and abundance scaling uncertainty for marine mammals. This approach allows us to explore the parameter space more thoroughly and find optimal parameter combinations that best match observed data.

**Key improvements incorporated from optimization scripts 11/12:**
- **Enhanced whale prioritization**: Whale species receive much higher weighting (5-10x) in fit evaluation
- **Additional performance metrics**: Beyond RMSE, includes MAE, bias, correlation, and relative error
- **Stricter steady-state criteria**: Minimum 1000 years t_max, tolerance â‰¤ 0.002
- **Enhanced spin-up protocol**: Multiple spin-up cycles with biomass stability validation
- **Biomass stability tolerance**: Final 50 years CV must be < 5% for stable simulations

## Setup for Combined Uncertainty Analysis

```{r combined-uncertainty-setup}
# Load required libraries for parallel processing
library(parallel)
library(doParallel)
library(foreach)

# Define species-specific weights emphasizing whale groups
species_weights <- data.frame(
  Species = c("minke whales", "sperm whales", "baleen whales", "orca",
             "antarctic krill", "bathypelagic fishes", "shelf and coastal fishes",
             "squids", "toothfishes"),
  weight = c(5,      # minke whales - high priority
            10,     # sperm whales - highest priority (worst fit historically)
            8,      # baleen whales - very high priority
            3,      # orca - moderate priority
            1,      # krill - standard (good fit already)
            1,      # bathypelagic - standard (good fit already)
            1,      # shelf/coastal - standard (good fit already)
            1,      # squids - standard
            1)      # toothfish - standard
)

cat("=== SPECIES WEIGHTING STRATEGY ===\n")
print(species_weights)
cat("Whale species receive 3-10x higher weighting for model fit evaluation\n\n")

# Enhanced biomass stability check function
check_biomass_stability_enhanced <- function(sim_object, tolerance = 0.05, check_years = 50) {
  # Check the coefficient of variation for the last check_years
  biomass <- getBiomass(sim_object)
  
  if (nrow(biomass) < check_years) {
    return(FALSE)  # Not enough data
  }
  
  # Get last check_years of data
  recent_biomass <- tail(biomass, check_years)
  
  # Calculate CV for each species
  cv_by_species <- apply(recent_biomass, 2, function(x) {
    if (mean(x) == 0) return(Inf)
    sd(x) / mean(x)
  })
  
  # Check if all species have CV below tolerance
  all_stable <- all(cv_by_species < tolerance, na.rm = TRUE)
  
  if (!all_stable) {
    unstable_species <- names(cv_by_species)[cv_by_species >= tolerance]
    cat("Unstable species (CV >=", tolerance * 100, "%): ", 
        paste(unstable_species, collapse = ", "), "\n")
  }
  
  return(all_stable)
}

# Enhanced steady-state function with stricter criteria
enhanced_steady_state <- function(params, 
                                  tol = 0.002,           # Stricter tolerance
                                  t_max = 1000,          # Minimum 1000 years
                                  preserve_erepro = TRUE,
                                  max_attempts = 3) {
  
  attempt <- 1
  while (attempt <= max_attempts) {
    cat("Steady-state attempt", attempt, "of", max_attempts, "\n")
    
    tryCatch({
      if (preserve_erepro) {
        params_steady <- steady(params, tol = tol, t_max = t_max, preserve = c("erepro"))
      } else {
        params_steady <- steady(params, tol = tol, t_max = t_max)
      }
      
      # Validate steady state by running a short simulation
      test_sim <- project(params_steady, t_max = 50, effort = 0)
      if (check_biomass_stability_enhanced(test_sim, tolerance = 0.01, check_years = 20)) {
        cat("Steady-state achieved and validated\n")
        return(params_steady)
      } else {
        cat("Steady-state achieved but not stable, increasing t_max\n")
        t_max <- t_max * 1.5
      }
    }, error = function(e) {
      cat("Steady-state failed:", e$message, "\nIncreasing t_max and trying again\n")
      t_max <- t_max * 1.5
    })
    
    attempt <- attempt + 1
  }
  
  # If all attempts failed, return original params with warning
  warning("Enhanced steady-state failed after", max_attempts, "attempts. Using original parameters.")
  return(params)
}

# Enhanced spin-up function with multiple cycles and stability checks
enhanced_spinup <- function(params,
                           spinup_years = 118,
                           spinup_multiplier = 1,    # Can be 2, 3, or 4 for extended spinup
                           effort_scenario,
                           stability_tolerance = 0.05,
                           t_start = 1841,
                           final_years = 170) {
  
  total_spinup_years <- spinup_years * spinup_multiplier
  cat("Running enhanced spinup for", total_spinup_years, "years (", spinup_multiplier, "x base period)\n")
  
  # Step 1: Initial spinup without fishing
  sim_spinup <- project(params, 
                       t_start = t_start, 
                       t_max = total_spinup_years,
                       effort = 0)
  
  # Step 2: Check biomass stability during spinup
  is_stable <- check_biomass_stability_enhanced(sim_spinup, 
                                               tolerance = stability_tolerance, 
                                               check_years = min(50, total_spinup_years))
  
  if (!is_stable) {
    cat("Spinup not stable, extending by 50%\n")
    # Extend spinup if not stable
    extended_spinup <- project(params,
                              initial_n = sim_spinup@n[total_spinup_years,,],
                              t_start = t_start + total_spinup_years,
                              t_max = round(total_spinup_years * 0.5),
                              effort = 0)
    
    final_initial_n <- extended_spinup@n[round(total_spinup_years * 0.5),,]
  } else {
    cat("Spinup achieved stability\n")
    final_initial_n <- sim_spinup@n[total_spinup_years,,]
  }
  
  # Step 3: Run main simulation with fishing effort
  sim_final <- project(params,
                      initial_n = final_initial_n,
                      t_start = t_start,
                      t_max = final_years,
                      effort = effort_scenario)
  
  return(list(
    simulation = sim_final,
    spinup_stable = is_stable,
    final_initial_n = final_initial_n
  ))
}

# Enhanced model performance evaluation with multiple metrics
calculate_enhanced_performance_metrics <- function(sim_object,
                                                  yield_obs_data,
                                                  species_weights_df = species_weights,
                                                  species_list = NULL,
                                                  year_range = NULL) {
  
  # Get modeled yield
  mod_yield <- getYield(sim_object)
  df_mod <- reshape2::melt(mod_yield)
  names(df_mod) <- c("Year", "Species", "Yield")
  
  # Filter by year range and species if specified
  if (!is.null(year_range)) {
    df_mod <- df_mod[df_mod$Year >= min(year_range) & df_mod$Year <= max(year_range), ]
    yield_obs_data <- yield_obs_data[yield_obs_data$Year >= min(year_range) &
                                     yield_obs_data$Year <= max(year_range), ]
  }
  
  if (!is.null(species_list)) {
    df_mod <- df_mod[df_mod$Species %in% species_list, ]
    yield_obs_data <- yield_obs_data[yield_obs_data$Species %in% species_list, ]
  }
  
  # Merge modeled and observed data
  comparison <- merge(df_mod, yield_obs_data,
                     by = c("Year", "Species"),
                     suffixes = c("_mod", "_obs"))
  
  # Calculate comprehensive metrics by species
  metrics_by_species <- comparison %>%
    group_by(Species) %>%
    summarise(
      RMSE = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)),
      MAE = mean(abs(Yield_mod - Yield_obs), na.rm = TRUE),
      Mean_Obs = mean(Yield_obs, na.rm = TRUE),
      Mean_Mod = mean(Yield_mod, na.rm = TRUE),
      Bias = mean(Yield_mod - Yield_obs, na.rm = TRUE),
      Relative_Error = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)) / mean(Yield_obs, na.rm = TRUE) * 100,
      Correlation = cor(Yield_mod, Yield_obs, use = "complete.obs"),
      MAPE = mean(abs((Yield_mod - Yield_obs) / Yield_obs), na.rm = TRUE) * 100,
      n_obs = n(),
      .groups = 'drop'
    )
  
  # Apply species weights and calculate weighted metrics
  metrics_weighted <- metrics_by_species %>%
    left_join(species_weights_df, by = "Species") %>%
    mutate(weight = ifelse(is.na(weight), 1, weight)) # Default weight of 1 for unspecified species
  
  # Calculate weighted overall metrics
  total_weighted_rmse <- weighted.mean(metrics_weighted$RMSE, 
                                       metrics_weighted$weight * metrics_weighted$n_obs, 
                                       na.rm = TRUE)
  
  total_weighted_mae <- weighted.mean(metrics_weighted$MAE,
                                      metrics_weighted$weight * metrics_weighted$n_obs,
                                      na.rm = TRUE)
  
  total_weighted_bias <- weighted.mean(metrics_weighted$Bias,
                                       metrics_weighted$weight * metrics_weighted$n_obs,
                                       na.rm = TRUE)
  
  avg_correlation <- mean(metrics_weighted$Correlation, na.rm = TRUE)
  
  # Calculate composite score (lower is better)
  # Combines multiple metrics with emphasis on RMSE
  composite_score <- (total_weighted_rmse * 0.4) + 
                    (total_weighted_mae * 0.3) + 
                    (abs(total_weighted_bias) * 0.2) + 
                    ((1 - avg_correlation) * 0.1)
  
  return(list(
    total_weighted_rmse = total_weighted_rmse,
    total_weighted_mae = total_weighted_mae,
    total_weighted_bias = total_weighted_bias,
    avg_correlation = avg_correlation,
    composite_score = composite_score,
    metrics_by_species = metrics_by_species,
    metrics_weighted = metrics_weighted,
    comparison_data = comparison
  ))
}

# Function to run a single simulation with enhanced protocols
run_enhanced_single_sim <- function(sim_id, params, catchability_sd, abundance_sd,
                                   marine_mammal_species, effort_scen, 
                                   enhanced_steady_tol, enhanced_steady_t_max,
                                   spinup_years, spinup_multiplier,
                                   t_start, sim_years,
                                   preserve_erepro, max_erepro,
                                   species_weights_df,
                                   yield_obs_data) {
  
  cat("Starting enhanced simulation", sim_id, "\n")
  
  # Create copy of params
  rand_params <- params
  
  # Step 1: Randomize catchability for fished species
  gear_df <- gear_params(rand_params)
  original_catchability <- gear_df$catchability
  
  if(nrow(gear_df) > 0) {
    for(j in 1:nrow(gear_df)) {
      if(gear_df$catchability[j] > 0) {
        noise <- rnorm(1, mean = 0, sd = catchability_sd)
        gear_df$catchability[j] <- gear_df$catchability[j] * exp(noise)
        gear_df$catchability[j] <- min(1, max(0, gear_df$catchability[j]))
      }
    }
    gear_params(rand_params) <- gear_df
  }
  
  # Step 2: Randomize marine mammal abundance
  sp_params <- species_params(rand_params)
  species_indices <- which(sp_params$species %in% marine_mammal_species)
  scaling_factors <- exp(rnorm(length(species_indices), mean = 0, sd = abundance_sd))
  
  for (k in seq_along(species_indices)) {
    rand_params@initial_n[species_indices[k],] <-
      rand_params@initial_n[species_indices[k],] * scaling_factors[k]
  }
  
  # Step 3: Enhanced steady state
  rand_params <- enhanced_steady_state(rand_params, 
                                       tol = enhanced_steady_tol,
                                       t_max = enhanced_steady_t_max,
                                       preserve_erepro = preserve_erepro)
  
  # Check erepro if not preserving
  if (!preserve_erepro) {
    current_erepro <- species_params(rand_params)$erepro
    if (any(current_erepro > max_erepro, na.rm = TRUE)) {
      return(list(
        success = FALSE,
        reason = "erepro_exceeded",
        sim_id = sim_id
      ))
    }
  }
  
  # Step 4: Enhanced spinup and main simulation
  sim_result <- enhanced_spinup(rand_params,
                               spinup_years = spinup_years,
                               spinup_multiplier = spinup_multiplier,
                               effort_scenario = effort_scen,
                               t_start = t_start,
                               final_years = sim_years)
  
  # Step 5: Validate final simulation stability
  final_stable <- check_biomass_stability_enhanced(sim_result$simulation, 
                                                  tolerance = 0.05, 
                                                  check_years = 50)
  
  if (!final_stable) {
    return(list(
      success = FALSE,
      reason = "final_instability",
      sim_id = sim_id
    ))
  }
  
  # Step 6: Calculate enhanced performance metrics
  performance <- calculate_enhanced_performance_metrics(sim_result$simulation,
                                                       yield_obs_data,
                                                       species_weights_df)
  
  cat("Simulation", sim_id, "completed successfully. Composite score:", 
      round(performance$composite_score, 4), "\n")
  
  return(list(
    success = TRUE,
    sim_id = sim_id,
    simulation = sim_result$simulation,
    performance = performance,
    spinup_stable = sim_result$spinup_stable,
    params_info = list(
      sim_id = sim_id,
      catchability = gear_df$catchability,
      catchability_change = gear_df$catchability / original_catchability,
      marine_mammal_scaling = scaling_factors,
      marine_mammal_species = marine_mammal_species[seq_along(scaling_factors)],
      erepro_values = species_params(rand_params)$erepro
    )
  ))
}

# Main function to run enhanced combined uncertainty simulations
run_enhanced_combined_uncertainty_sims <- function(params,
                                                   n_sims = 10,
                                                   catchability_sd = 0.1,
                                                   abundance_sd = 0.2,
                                                   marine_mammal_species = NULL,
                                                   effort_scen,
                                                   enhanced_steady_tol = 0.002,      # Stricter tolerance
                                                   enhanced_steady_t_max = 1000,     # Minimum 1000 years
                                                   spinup_years = 118,
                                                   spinup_multiplier = 2,             # 2x base spinup by default
                                                   t_start = 1841,
                                                   sim_years = 170,
                                                   preserve_erepro = TRUE,
                                                   max_erepro = 1,
                                                   species_weights_df = species_weights,
                                                   yield_obs_data,
                                                   n_cores = NULL,
                                                   parallel = TRUE) {
  
  # Default marine mammal species if not specified
  if (is.null(marine_mammal_species)) {
    marine_mammal_species <- c("minke whales", "orca", "sperm whales", "baleen whales")
  }
  
  # Determine number of cores to use
  if (is.null(n_cores)) {
    n_cores <- detectCores() - 1
  }
  n_cores <- min(n_cores, detectCores())
  
  # Progress message
  cat("=== ENHANCED COMBINED UNCERTAINTY ANALYSIS ===\n")
  cat("Running", n_sims, "simulations with enhanced protocols:\n")
  cat("  - Steady-state tolerance:", enhanced_steady_tol, "\n")
  cat("  - Minimum steady-state time:", enhanced_steady_t_max, "years\n")
  cat("  - Spinup multiplier:", spinup_multiplier, "x (", spinup_years * spinup_multiplier, "years total)\n")
  cat("  - Whale species weighting: 3-10x higher than fish/krill\n")
  cat("  - Performance metrics: RMSE, MAE, Bias, Correlation, Composite Score\n")
  
  if (preserve_erepro) {
    cat("  - Preserving erepro values during steady state\n")
  } else {
    cat("  - Will skip simulations with erepro >", max_erepro, "\n")
  }
  
  if (parallel && n_cores > 1) {
    cat("  - Using parallel processing with", n_cores, "cores\n")
    
    # Set up parallel cluster
    cl <- makeCluster(n_cores)
    registerDoParallel(cl)
    
    # Export necessary objects to cluster
    clusterExport(cl, c("run_enhanced_single_sim", "enhanced_steady_state", 
                       "enhanced_spinup", "check_biomass_stability_enhanced",
                       "calculate_enhanced_performance_metrics",
                       "species_weights_df", "yield_obs_data"), 
                  envir = environment())
    
    # Run simulations in parallel
    n_attempts <- ifelse(preserve_erepro, n_sims, ceiling(n_sims * 2))
    
    cat("  - Running", n_attempts, "initial attempts...\n")
    
    results <- foreach(i = 1:n_attempts,
                      .packages = c("mizer", "therMizer", "dplyr"),
                      .errorhandling = "pass") %dopar% {
      run_enhanced_single_sim(i, params, catchability_sd, abundance_sd,
                             marine_mammal_species, effort_scen, 
                             enhanced_steady_tol, enhanced_steady_t_max,
                             spinup_years, spinup_multiplier,
                             t_start, sim_years,
                             preserve_erepro, max_erepro,
                             species_weights_df, yield_obs_data)
    }
    
    # Stop cluster
    stopCluster(cl)
    
  } else {
    # Sequential processing
    cat("  - Using sequential processing\n")
    
    n_attempts <- ifelse(preserve_erepro, n_sims, ceiling(n_sims * 2))
    results <- list()
    
    for(i in 1:n_attempts) {
      if(i %% 5 == 0) cat("    Processing simulation", i, "of", n_attempts, "\n")
      
      results[[i]] <- run_enhanced_single_sim(i, params, catchability_sd, abundance_sd,
                                             marine_mammal_species, effort_scen, 
                                             enhanced_steady_tol, enhanced_steady_t_max,
                                             spinup_years, spinup_multiplier,
                                             t_start, sim_years,
                                             preserve_erepro, max_erepro,
                                             species_weights_df, yield_obs_data)
    }
  }
  
  # Process results
  sim_results <- list()
  param_combinations <- list()
  performance_results <- list()
  failed_sims <- list()
  successful_count <- 0
  
  for(res in results) {
    if(!is.null(res) && !inherits(res, "error")) {
      if(res$success) {
        successful_count <- successful_count + 1
        if(successful_count <= n_sims) {
          sim_results[[successful_count]] <- res$simulation
          param_combinations[[successful_count]] <- res$params_info
          performance_results[[successful_count]] <- res$performance
        }
      } else {
        failed_sims[[length(failed_sims) + 1]] <- res
      }
    }
  }
  
  # Final summary
  cat("\n=== ENHANCED SIMULATION RESULTS ===\n")
  cat("Completed", min(successful_count, n_sims), "successful simulations\n")
  if (length(failed_sims) > 0) {
    failure_reasons <- table(sapply(failed_sims, function(x) x$reason))
    cat("Failed simulations by reason:\n")
    print(failure_reasons)
  }
  
  # Calculate summary statistics of performance
  if (length(performance_results) > 0) {
    composite_scores <- sapply(performance_results, function(x) x$composite_score)
    rmse_scores <- sapply(performance_results, function(x) x$total_weighted_rmse)
    
    cat("\nPerformance Summary:\n")
    cat("  Composite Score - Mean:", round(mean(composite_scores), 4), 
        "Range:", round(min(composite_scores), 4), "-", round(max(composite_scores), 4), "\n")
    cat("  Weighted RMSE - Mean:", round(mean(rmse_scores), 4),
        "Range:", round(min(rmse_scores), 4), "-", round(max(rmse_scores), 4), "\n")
  }
  
  # Trim to requested number of simulations
  if(length(sim_results) > n_sims) {
    sim_results <- sim_results[1:n_sims]
    param_combinations <- param_combinations[1:n_sims]
    performance_results <- performance_results[1:n_sims]
  }
  
  return(list(
    simulations = sim_results,
    parameters = param_combinations,
    performance = performance_results,
    failed = failed_sims,
    n_successful = length(sim_results),
    n_attempts = length(results)
  ))
}

# Function to find optimal parameters based on enhanced metrics
find_optimal_parameters_enhanced <- function(sim_results_list, metric = "composite_score") {
  
  # Extract performance metrics
  performance_data <- sim_results_list$performance
  
  if (length(performance_data) == 0) {
    stop("No performance data available")
  }
  
  # Get the specified metric values
  metric_values <- sapply(performance_data, function(x) {
    if (metric %in% names(x)) {
      return(x[[metric]])
    } else {
      return(NA)
    }
  })
  
  # Find optimal (minimum for most metrics)
  if (metric == "avg_correlation") {
    optimal_idx <- which.max(metric_values)  # Higher correlation is better
  } else {
    optimal_idx <- which.min(metric_values)  # Lower is better for RMSE, MAE, bias, composite
  }
  
  if (length(optimal_idx) == 0 || is.na(optimal_idx)) {
    stop("Could not find optimal simulation for metric:", metric)
  }
  
  # Create summary statistics
  metric_stats <- data.frame(
    mean = mean(metric_values, na.rm = TRUE),
    median = median(metric_values, na.rm = TRUE),
    sd = sd(metric_values, na.rm = TRUE),
    min = min(metric_values, na.rm = TRUE),
    max = max(metric_values, na.rm = TRUE),
    q25 = quantile(metric_values, 0.25, na.rm = TRUE),
    q75 = quantile(metric_values, 0.75, na.rm = TRUE)
  )
  
  cat("\n=== OPTIMAL PARAMETER SELECTION ===\n")
  cat("Optimization metric:", metric, "\n")
  cat("Optimal simulation:", optimal_idx, "with", metric, "=", metric_values[optimal_idx], "\n")
  cat("\nMetric Statistics:\n")
  print(metric_stats)
  
  # Extract detailed performance for optimal simulation
  optimal_performance <- performance_data[[optimal_idx]]
  
  cat("\n=== OPTIMAL SIMULATION PERFORMANCE ===\n")
  cat("Weighted RMSE:", round(optimal_performance$total_weighted_rmse, 4), "\n")
  cat("Weighted MAE:", round(optimal_performance$total_weighted_mae, 4), "\n")
  cat("Weighted Bias:", round(optimal_performance$total_weighted_bias, 4), "\n")
  cat("Average Correlation:", round(optimal_performance$avg_correlation, 4), "\n")
  cat("Composite Score:", round(optimal_performance$composite_score, 4), "\n")
  
  cat("\nSpecies-specific performance:\n")
  print(optimal_performance$metrics_by_species)
  
  return(list(
    optimal_index = optimal_idx,
    optimal_metric_value = metric_values[optimal_idx],
    optimal_sim = sim_results_list$simulations[[optimal_idx]],
    optimal_params = sim_results_list$parameters[[optimal_idx]],
    optimal_performance = optimal_performance,
    all_metric_values = metric_values,
    metric_stats = metric_stats,
    metric_used = metric
  ))
}

# Function to plot RMSE distribution from uncertainty analysis
plot_rmse_distribution <- function(rmse_values,
                                  optimal_idx = NULL,
                                  plot_title = "RMSE Distribution from Combined Parameter Uncertainty") {
  
  require(ggplot2)
  
  df <- data.frame(
    Simulation = 1:length(rmse_values),
    RMSE = rmse_values
  )
  
  # Calculate statistics for annotation
  mean_rmse <- mean(rmse_values)
  median_rmse <- median(rmse_values)
  
  p <- ggplot(df, aes(x = RMSE)) +
    geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "black") +
    theme_bw() +
    labs(
      title = plot_title,
      subtitle = paste("n =", length(rmse_values), "simulations"),
      x = "RMSE (Root Mean Square Error)",
      y = "Frequency"
    ) +
    # Add mean line
    geom_vline(xintercept = mean_rmse,
              color = "blue", linetype = "dotted", linewidth = 1) +
    # Add median line
    geom_vline(xintercept = median_rmse,
              color = "green", linetype = "dotted", linewidth = 1)
  
  # Add vertical line for optimal value if provided
  if (!is.null(optimal_idx)) {
    p <- p +
      geom_vline(xintercept = rmse_values[optimal_idx],
                color = "red", linetype = "dashed", linewidth = 1) +
      annotate("text",
              x = rmse_values[optimal_idx],
              y = max(table(cut(rmse_values, 30))) * 0.9,
              label = paste("Optimal RMSE =", round(rmse_values[optimal_idx], 2)),
              hjust = -0.1, color = "red")
  }
  
  # Add legend for lines
  p <- p +
    annotate("text", x = mean_rmse, y = max(table(cut(rmse_values, 30))) * 0.8,
            label = paste("Mean =", round(mean_rmse, 2)),
            hjust = -0.1, color = "blue", size = 3) +
    annotate("text", x = median_rmse, y = max(table(cut(rmse_values, 30))) * 0.7,
            label = paste("Median =", round(median_rmse, 2)),
            hjust = -0.1, color = "green", size = 3)
  
  return(p)
}

# Function to visualize parameter combinations
plot_parameter_exploration <- function(param_combinations, rmse_values) {
  
  require(ggplot2)
  require(tidyr)
  require(dplyr)
  
  # Extract catchability and marine mammal scaling
  df_params <- data.frame(
    sim_id = 1:length(param_combinations),
    rmse = rmse_values
  )
  
  # Add catchability info (assuming single gear for simplicity)
  df_params$catchability <- sapply(param_combinations, function(x) mean(x$catchability))
  
  # Add marine mammal scaling (mean across all marine mammals)
  df_params$mammal_scaling <- sapply(param_combinations, function(x) mean(x$marine_mammal_scaling))
  
  # Create scatter plot
  p1 <- ggplot(df_params, aes(x = catchability, y = mammal_scaling, color = rmse)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_gradient(low = "blue", high = "red", name = "RMSE") +
    theme_bw() +
    labs(
      title = "Parameter Space Exploration",
      x = "Mean Catchability",
      y = "Mean Marine Mammal Scaling Factor"
    )
  
  # Create individual parameter distributions
  p2 <- ggplot(df_params, aes(x = catchability)) +
    geom_histogram(bins = 20, fill = "steelblue", alpha = 0.7) +
    theme_bw() +
    labs(title = "Catchability Distribution", x = "Catchability", y = "Count")
  
  p3 <- ggplot(df_params, aes(x = mammal_scaling)) +
    geom_histogram(bins = 20, fill = "darkgreen", alpha = 0.7) +
    theme_bw() +
    labs(title = "Marine Mammal Scaling Distribution", x = "Scaling Factor", y = "Count")
  
  # Combine plots
  require(gridExtra)
  combined_plot <- grid.arrange(p1, p2, p3, ncol = 2, nrow = 2)
  
  return(combined_plot)
}
```

## Run Enhanced Combined Uncertainty Analysis

Now we'll run the enhanced combined uncertainty analysis with stricter steady-state criteria, extended spinup, whale species weighting, and multiple performance metrics:

```{r run-enhanced-combined-uncertainty, eval=FALSE}
# Load required data if not already loaded
if (!exists("combined_effort_array")) {
  combined_effort_array <- readRDS("effort_array_1841_2010.rds")
}

if (!exists("yield_ts_tidy")) {
  yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")
}

# Run enhanced combined uncertainty simulations
# Using moderate uncertainty for both parameters with enhanced protocols
enhanced_uncertainty_results <- run_enhanced_combined_uncertainty_sims(
  params = params_1841_2010_climate_only,
  n_sims = 200,  # Start with smaller number due to enhanced processing time
  catchability_sd = 0.4,  # 20% CV for catchability
  abundance_sd = 0.8,  # 30% CV for marine mammal abundance
  marine_mammal_species = c("minke whales", "orca", "sperm whales", "baleen whales"),
  effort_scen = combined_effort_array,
  enhanced_steady_tol = 0.002,    # Stricter tolerance (vs 0.01 previously)
  enhanced_steady_t_max = 1000,   # Minimum 1000 years (vs 500 previously)
  spinup_years = 118,
  spinup_multiplier = 2,          # 2x spinup (236 years total)
  t_start = 1841,
  sim_years = 170,
  preserve_erepro = TRUE,
  max_erepro = 1,
  species_weights_df = species_weights,  # Use whale-weighted evaluation
  yield_obs_data = yield_ts_tidy,
  n_cores = NULL,  # NULL = use all available cores minus 1
  parallel = TRUE  # Set to FALSE for sequential processing if needed
)

# Example for running with even more intensive protocols
# enhanced_uncertainty_results_intensive <- run_enhanced_combined_uncertainty_sims(
#   params = params_1841_2010_fishing_only,
#   n_sims = 100,
#   catchability_sd = 0.2,
#   abundance_sd = 0.3,
#   marine_mammal_species = c("minke whales", "orca", "sperm whales", "baleen whales"),
#   effort_scen = combined_effort_array,
#   enhanced_steady_tol = 0.001,    # Even stricter
#   enhanced_steady_t_max = 1500,   # Longer steady-state
#   spinup_years = 118,
#   spinup_multiplier = 3,          # 3x spinup (354 years total)
#   t_start = 1841,
#   sim_years = 170,
#   preserve_erepro = TRUE,
#   species_weights_df = species_weights,
#   yield_obs_data = yield_ts_tidy,
#   n_cores = 8,  # Use 8 cores
#   parallel = TRUE
# )

# Display summary of results
cat("\n=== ENHANCED SIMULATION SUMMARY ===\n")
cat("Successful simulations:", enhanced_uncertainty_results$n_successful, "\n")
cat("Total attempts:", enhanced_uncertainty_results$n_attempts, "\n")
if (length(enhanced_uncertainty_results$failed) > 0) {
  cat("Failed simulations:", length(enhanced_uncertainty_results$failed), "\n")
}

# Save results
saveRDS(enhanced_uncertainty_results, "enhanced_uncertainty_results.RDS")
```

## Analyze Enhanced Results and Find Optimal Parameters

```{r analyze-enhanced-results, eval=FALSE}
# Find optimal parameters based on different metrics
# 1. Composite score (combines RMSE, MAE, bias, correlation)
optimal_results_composite <- find_optimal_parameters_enhanced(
  sim_results_list = enhanced_uncertainty_results,
  metric = "composite_score"
)

# 2. Weighted RMSE only (for comparison)
optimal_results_rmse <- find_optimal_parameters_enhanced(
  sim_results_list = enhanced_uncertainty_results,
  metric = "total_weighted_rmse"
)

# 3. Correlation (for models that capture yield patterns well)
optimal_results_correlation <- find_optimal_parameters_enhanced(
  sim_results_list = enhanced_uncertainty_results,
  metric = "avg_correlation"
)

# Save optimal results
saveRDS(optimal_results_composite, "optimal_parameter_results_composite.RDS")
saveRDS(optimal_results_rmse, "optimal_parameter_results_rmse.RDS")
saveRDS(optimal_results_correlation, "optimal_parameter_results_correlation.RDS")

# Display comparison of different optimization metrics
cat("\n=== COMPARISON OF OPTIMIZATION APPROACHES ===\n")
cat("Composite Score Optimal - Simulation:", optimal_results_composite$optimal_index, 
    "Score:", round(optimal_results_composite$optimal_metric_value, 4), "\n")
cat("RMSE Optimal - Simulation:", optimal_results_rmse$optimal_index,
    "RMSE:", round(optimal_results_rmse$optimal_metric_value, 4), "\n")
cat("Correlation Optimal - Simulation:", optimal_results_correlation$optimal_index,
    "Correlation:", round(optimal_results_correlation$optimal_metric_value, 4), "\n")

# Compare performance across metrics for the composite score optimal model
best_model_performance <- optimal_results_composite$optimal_performance
cat("\n=== BEST MODEL (COMPOSITE SCORE) DETAILED PERFORMANCE ===\n")
cat("Weighted RMSE:", round(best_model_performance$total_weighted_rmse, 4), "\n")
cat("Weighted MAE:", round(best_model_performance$total_weighted_mae, 4), "\n")
cat("Weighted Bias:", round(best_model_performance$total_weighted_bias, 4), "\n")
cat("Average Correlation:", round(best_model_performance$avg_correlation, 4), "\n")
cat("Composite Score:", round(best_model_performance$composite_score, 4), "\n")

# Display whale-specific performance (highest weighted species)
whale_species <- c("minke whales", "orca", "sperm whales", "baleen whales")
whale_performance <- best_model_performance$metrics_by_species %>%
  filter(Species %in% whale_species) %>%
  arrange(RMSE)

cat("\n=== WHALE SPECIES PERFORMANCE (High Weight Groups) ===\n")
print(whale_performance)

# Display optimal parameters for the best model
cat("\n=== OPTIMAL PARAMETER COMBINATION (COMPOSITE SCORE) ===\n")
cat("Simulation ID:", optimal_results_composite$optimal_index, "\n")
cat("\nCatchability values:\n")
print(optimal_results_composite$optimal_params$catchability)
cat("\nMarine mammal scaling factors:\n")
scaling_df <- data.frame(
  Species = optimal_results_composite$optimal_params$marine_mammal_species,
  Scaling_Factor = optimal_results_composite$optimal_params$marine_mammal_scaling,
  Scaling_Percent = paste0(round((optimal_results_composite$optimal_params$marine_mammal_scaling - 1) * 100, 1), "%")
)
print(scaling_df)
```

## Visualize Enhanced Uncertainty Analysis Results

```{r visualize-enhanced-results, eval=FALSE}
# Plot performance metric distributions
plot_enhanced_performance_distributions <- function(performance_results, metric_name) {
  require(ggplot2)
  
  metric_values <- sapply(performance_results, function(x) x[[metric_name]])
  
  df <- data.frame(
    Simulation = 1:length(metric_values),
    Value = metric_values
  )
  
  p <- ggplot(df, aes(x = Value)) +
    geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "black") +
    theme_bw() +
    labs(
      title = paste("Distribution of", metric_name),
      subtitle = paste("n =", length(metric_values), "simulations"),
      x = metric_name,
      y = "Frequency"
    ) +
    geom_vline(xintercept = mean(metric_values, na.rm = TRUE),
              color = "red", linetype = "dashed", linewidth = 1) +
    annotate("text",
            x = mean(metric_values, na.rm = TRUE),
            y = max(table(cut(metric_values, 30))) * 0.8,
            label = paste("Mean =", round(mean(metric_values, na.rm = TRUE), 3)),
            hjust = -0.1, color = "red")
  
  return(p)
}

# Create performance distribution plots
p_composite <- plot_enhanced_performance_distributions(
  enhanced_uncertainty_results$performance, "composite_score")
p_rmse <- plot_enhanced_performance_distributions(
  enhanced_uncertainty_results$performance, "total_weighted_rmse")
p_correlation <- plot_enhanced_performance_distributions(
  enhanced_uncertainty_results$performance, "avg_correlation")

# Save plots
ggsave("plots/enhanced_composite_score_distribution.png", p_composite,
       width = 10, height = 6, dpi = 300)
ggsave("plots/enhanced_rmse_distribution.png", p_rmse,
       width = 10, height = 6, dpi = 300)
ggsave("plots/enhanced_correlation_distribution.png", p_correlation,
       width = 10, height = 6, dpi = 300)

# Plot species-specific performance comparison
plot_species_performance_comparison <- function(performance_results, species_weights_df) {
  require(ggplot2)
  require(dplyr)
  
  # Extract species metrics from all simulations
  all_species_metrics <- do.call(rbind, lapply(1:length(performance_results), function(i) {
    metrics <- performance_results[[i]]$metrics_by_species
    metrics$Simulation <- i
    return(metrics)
  }))
  
  # Add weights
  all_species_metrics <- all_species_metrics %>%
    left_join(species_weights_df, by = "Species") %>%
    mutate(weight = ifelse(is.na(weight), 1, weight),
           Species_Type = ifelse(Species %in% c("minke whales", "orca", "sperm whales", "baleen whales"),
                                "Whale (High Weight)", "Fish/Krill (Standard Weight)"))
  
  # Create boxplot
  p_species <- ggplot(all_species_metrics, aes(x = reorder(Species, RMSE, median), 
                                               y = RMSE, fill = Species_Type)) +
    geom_boxplot(alpha = 0.7) +
    scale_fill_manual(values = c("Whale (High Weight)" = "coral", 
                                "Fish/Krill (Standard Weight)" = "lightblue")) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
      title = "Species-Specific RMSE Distribution",
      subtitle = "Showing uncertainty across parameter combinations",
      x = "Species (ordered by median RMSE)",
      y = "RMSE",
      fill = "Species Group"
    )
  
  return(p_species)
}

p_species_comparison <- plot_species_performance_comparison(
  enhanced_uncertainty_results$performance, species_weights)
print(p_species_comparison)
ggsave("plots/enhanced_species_performance_comparison.png", p_species_comparison,
       width = 14, height = 8, dpi = 300)
```
)
print(p_rmse_dist)
ggsave("plots/combined_uncertainty_rmse_distribution_flex_erepro_catchSD_0.5_abSD_2.png", p_rmse_dist,
       width = 10, height = 6, dpi = 300)

# Plot parameter exploration
p_param_explore <- plot_parameter_exploration(
  param_combinations = combined_uncertainty_results$parameters,
  rmse_values = optimal_results$all_rmse
)
ggsave("plots/combined_parameter_exploration_flex_erepro_catchSD_0.5_abSD_2.png", p_param_explore,
       width = 12, height = 10, dpi = 300)
```

## Compare Enhanced Optimal Simulation with Observations

```{r compare-enhanced-optimal-simulation, eval=FALSE}
# Prepare uncertainty bounds data for yield plotting with enhanced results
# Extract yield data from all simulations for uncertainty bounds
trimYield_uncertainty <- function(sim) {
  y <- plotYieldGear(sim, return_data = T)
  y <- select(y, c(Year, Species, Yield))
  return(y)
}

sim_yields_uncertainty <- lapply(enhanced_uncertainty_results$simulations, trimYield_uncertainty)
for (i in 1:length(sim_yields_uncertainty)) {
  sim_yields_uncertainty[[i]]$sim <- i
}

df_sim_yield_uncertainty <- do.call(rbind.data.frame, sim_yields_uncertainty)

# Calculate uncertainty bounds for yield
sim_mean_yield <- df_sim_yield_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Yield = median(Yield)) %>% 
  ungroup()

sim_lower_yield <- df_sim_yield_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Yield = quantile(Yield, 0.025)) %>% 
  ungroup()

sim_upper_yield <- df_sim_yield_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Yield = quantile(Yield, 0.975)) %>% 
  ungroup()

# Combine uncertainty bounds data
uncertainty_yield_data <- data.frame(
  Species = sim_mean_yield$Species, 
  Year = sim_mean_yield$Year,
  sim_mean = sim_mean_yield$Yield,
  sim_lower = sim_lower_yield$Yield,
  sim_upper = sim_upper_yield$Yield
)

# Prepare uncertainty bounds data for biomass plotting
getBiomassData <- function(sim) {
  biomass <- getBiomass(sim)
  df_biomass <- reshape2::melt(biomass)
  names(df_biomass) <- c("Year", "Species", "Biomass")
  return(df_biomass)
}

sim_biomass_uncertainty <- lapply(enhanced_uncertainty_results$simulations, getBiomassData)
for (i in 1:length(sim_biomass_uncertainty)) {
  sim_biomass_uncertainty[[i]]$sim <- i
}

df_sim_biomass_uncertainty <- do.call(rbind.data.frame, sim_biomass_uncertainty)

# Calculate uncertainty bounds for biomass
sim_mean_biomass <- df_sim_biomass_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Biomass = median(Biomass)) %>% 
  ungroup()

sim_lower_biomass <- df_sim_biomass_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Biomass = quantile(Biomass, 0.025)) %>% 
  ungroup()

sim_upper_biomass <- df_sim_biomass_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Biomass = quantile(Biomass, 0.975)) %>% 
  ungroup()

# Combine uncertainty bounds data for biomass
uncertainty_biomass_data <- data.frame(
  Species = sim_mean_biomass$Species, 
  Year = sim_mean_biomass$Year,
  sim_mean = sim_mean_biomass$Biomass,
  sim_lower = sim_lower_biomass$Biomass,
  sim_upper = sim_upper_biomass$Biomass
)

# Get original baseline model data (params_new_v4)
sim_baseline_yield <- project(params_new_v4, effort = combined_effort_array, t_start = 1841, t_max = 170)
baseline_yield_data <- trimYield_uncertainty(sim_baseline_yield)

sim_baseline_biomass <- project(params_new_v4, effort = combined_effort_array, t_start = 1841, t_max = 170)
baseline_biomass_data <- getBiomassData(sim_baseline_biomass)

# New facet label names for species
species.labs <- c("Antarctic krill", "Bathypelagic fishes", "Shelf & Coastal fishes", 
                  "Squids", "Toothfishes", "Antarctic minke whales", "Orcas", 
                  "Sperm whales", "Baleen whales")
names(species.labs) <- c("antarctic krill", "bathypelagic fishes", "shelf and coastal fishes", 
                         "squids", "toothfishes", "minke whales", "orca", "sperm whales", "baleen whales")

# Plot yield comparison for optimal simulation with uncertainty bounds (using composite score optimal)
p_yield_optimal <- plotYield(optimal_results_composite$optimal_sim) + 
  facet_wrap(~Species, scales = "free_y",
             labeller = labeller(Species = species.labs)) +
  labs(fill = "Functional group", 
       title = "Enhanced Optimal Simulation: Yield with Uncertainty & Whale-Weighted Fitting",
       subtitle = paste("Composite Score:", round(optimal_results_composite$optimal_metric_value, 4),
                       "| Weighted RMSE:", round(optimal_results_composite$optimal_performance$total_weighted_rmse, 4))) +
  # Add uncertainty ribbon
  geom_ribbon(data = uncertainty_yield_data, 
              aes(x = Year, ymin = sim_lower, ymax = sim_upper), 
              alpha = 0.3, colour = NA, fill = "lightblue") +
  # Add baseline model line (original params_new_v4)
  geom_line(data = baseline_yield_data, 
            aes(x = Year, y = Yield), 
            color = "gray60", linetype = "dashed", linewidth = 1) +
  # Add optimal model line (solid black for best fit)
  geom_line(aes(color = Species), linewidth = 1.2) +
  # Add observed data points
  geom_point(data = yield_ts_tidy, 
             aes(x = Year, y = Yield, colour = Species), 
             size = 1) +
  geom_point(data = yield_ts_tidy, 
             aes(x = Year, y = Yield), 
             shape = 1, size = 1, colour = "black") +
  # Add vertical reference lines
  geom_vline(aes(xintercept = 1961), linetype = "dotted", alpha = 0.7) + 
  geom_vline(aes(xintercept = 2010), linetype = "dotted", alpha = 0.7) +
  theme_bw() +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold"),
    plot.subtitle = element_text(size = 10)
  )

print(p_yield_optimal)
ggsave("plots/enhanced_optimal_simulation_yield.png", p_yield_optimal,
       width = 16, height = 12, dpi = 300)

# Plot biomass comparison for optimal simulation with uncertainty bounds
p_biomass_optimal <- plotBiomass(optimal_results_composite$optimal_sim) + 
  facet_wrap(~Species, scales = "free_y",
             labeller = labeller(Species = species.labs)) +
  labs(fill = "Functional group", 
       title = "Enhanced Optimal Simulation: Biomass with Uncertainty & Whale-Weighted Fitting",
       subtitle = paste("Composite Score:", round(optimal_results_composite$optimal_metric_value, 4),
                       "| Avg Correlation:", round(optimal_results_composite$optimal_performance$avg_correlation, 4))) +
  # Add uncertainty ribbon
  geom_ribbon(data = uncertainty_biomass_data, 
              aes(x = Year, ymin = sim_lower, ymax = sim_upper), 
              alpha = 0.3, colour = NA, fill = "lightgreen") +
  # Add baseline model line (original params_new_v4)
  geom_line(data = baseline_biomass_data, 
            aes(x = Year, y = Biomass), 
            color = "gray60", linetype = "dashed", linewidth = 1) +
  # Add optimal model line (solid black for best fit)
  geom_line(aes(color = Species), linewidth = 1.2) +
  # Add vertical reference lines
  geom_vline(aes(xintercept = 1961), linetype = "dotted", alpha = 0.7) + 
  geom_vline(aes(xintercept = 2010), linetype = "dotted", alpha = 0.7) +
  theme_bw() +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold"),
    plot.subtitle = element_text(size = 10)
  )

print(p_biomass_optimal)
ggsave("plots/enhanced_optimal_simulation_biomass.png", p_biomass_optimal,
       width = 16, height = 12, dpi = 300)

# Use the cleaned results from the previous chunk (or re-clean if needed)
if (!exists("cleaned_results")) {
  cleaned_results <- validate_simulation_results(combined_uncertainty_results, verbose = TRUE)
}

# Extract uncertainty bounds using the new helper function
# This automatically validates simulations and handles any invalid ones
cat("Extracting uncertainty bounds from simulations...\n")
uncertainty_bounds <- extract_uncertainty_bounds(
  sim_results_list = cleaned_results,
  confidence_level = 0.95,
  validate_first = FALSE,  # Already validated above
  verbose = TRUE
)

# Get the bounds
yield_bounds <- uncertainty_bounds$yield_bounds
biomass_bounds <- uncertainty_bounds$biomass_bounds

cat("Successfully extracted bounds from", uncertainty_bounds$n_simulations, "valid simulations\n")

# Species labels for faceting
species.labs <- c("Antarctic krill", "Bathypelagic fishes", "Shelf & Coastal fishes",
                  "Squids", "Toothfishes", "Antarctic minke whales", "Orcas",
                  "Sperm whales", "Baleen whales")
names(species.labs) <- c("antarctic krill", "bathypelagic fishes",
                         "shelf and coastal fishes", "squids", "toothfishes",
                         "minke whales", "orca", "sperm whales", "baleen whales")

# Plot yield comparison for optimal simulation with uncertainty bounds
p_yield_optimal <- plotYield(optimal_results$optimal_sim) +
  facet_wrap(~Species, scales = "free_y",
             labeller = labeller(Species = species.labs)) +
  # Add uncertainty ribbon
  geom_ribbon(data = yield_bounds,
              aes(x = Year, ymin = yield_lower, ymax = yield_upper),
              alpha = 0.3, fill = "lightblue", inherit.aes = FALSE) +
  # Add original model fit line
  geom_line(data = plotYieldGear(sim_original, return_data = TRUE),
            aes(x = Year, y = Yield),
            color = "darkgray", linetype = "dashed", linewidth = 1, inherit.aes = FALSE) +
  # Add best fit model line (solid black)
  geom_line(data = plotYieldGear(optimal_results$optimal_sim, return_data = TRUE),
            aes(x = Year, y = Yield),
            color = "black", linetype = "solid", linewidth = 1.2, inherit.aes = FALSE) +
  # Add observed data points
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield, colour = Species),
             size = 1, inherit.aes = FALSE) +
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield),
             shape = 1, size = 1, colour = "black", inherit.aes = FALSE) +
  # Add vertical reference lines
  geom_vline(aes(xintercept = 1961), linetype = "dotted", alpha = 0.7) +
  geom_vline(aes(xintercept = 2010), linetype = "dotted", alpha = 0.7) +
  theme_bw() +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 10)
  ) +
  labs(
    title = "Optimal Simulation: Modeled vs. Observed Yield with Uncertainty",
    subtitle = "Gray dashed = original model, Black solid = best fit, Blue ribbon = 95% CI",
    x = "Year",
    y = "Yield"
  )

print(p_yield_optimal)
ggsave("plots/optimal_simulation_yield_flex_erepro_catchSD_0.5_abSD_2.png", p_yield_optimal,
       width = 14, height = 10, dpi = 300)

# Get original model biomass data
original_biomass_matrix <- getBiomass(sim_original)
original_biomass_data <- reshape2::melt(original_biomass_matrix)
names(original_biomass_data) <- c("Year", "Species", "Biomass")

# Get optimal model biomass data
optimal_biomass_matrix <- getBiomass(optimal_results$optimal_sim)
optimal_biomass_data <- reshape2::melt(optimal_biomass_matrix)
names(optimal_biomass_data) <- c("Year", "Species", "Biomass")

# Plot biomass comparison for optimal simulation with uncertainty bounds
p_biomass_optimal <- plot_biomass_comparison(
  sim_object = optimal_results$optimal_sim,
  plot_title = "Optimal Simulation: Modeled vs. Observed Biomass with Uncertainty"
) +
  # Add uncertainty ribbon
  geom_ribbon(data = biomass_bounds,
              aes(x = Year, ymin = biomass_lower, ymax = biomass_upper),
              alpha = 0.3, fill = "lightcoral", inherit.aes = FALSE) +
  # Add original model fit line
  geom_line(data = original_biomass_data,
            aes(x = Year, y = Biomass),
            color = "darkgray", linetype = "dashed", linewidth = 1, inherit.aes = FALSE) +
  # Add best fit model line (solid black)
  geom_line(data = optimal_biomass_data,
            aes(x = Year, y = Biomass),
            color = "black", linetype = "solid", linewidth = 1.2, inherit.aes = FALSE) +
  labs(
    subtitle = "Gray dashed = original model, Black solid = best fit, Coral ribbon = 95% CI"
  )

print(p_biomass_optimal)
ggsave("plots/optimal_simulation_biomass_flex_erepro_catchSD_0.5_abSD_2.png", p_biomass_optimal,
       width = 14, height = 10, dpi = 300)
```

## Summary Statistics and Sensitivity Analysis

```{r sensitivity-analysis, eval=FALSE}
# Create summary table of RMSE by species
rmse_by_species_summary <- do.call(rbind, lapply(optimal_results$rmse_details,
                                                 function(x) x$rmse_by_species))
rmse_by_species_summary$sim_id <- rep(1:length(optimal_results$rmse_details),
                                      each = length(unique(rmse_by_species_summary$Species)))

# Calculate statistics by species
species_rmse_stats <- rmse_by_species_summary %>%
  group_by(Species) %>%
  summarise(
    mean_rmse = mean(RMSE, na.rm = TRUE),
    median_rmse = median(RMSE, na.rm = TRUE),
    sd_rmse = sd(RMSE, na.rm = TRUE),
    min_rmse = min(RMSE, na.rm = TRUE),
    max_rmse = max(RMSE, na.rm = TRUE)
  ) %>%
  arrange(mean_rmse)

cat("\n=== RMSE Statistics by Species ===\n")
print(species_rmse_stats)

# Plot species-specific RMSE distributions
p_species_rmse <- ggplot(rmse_by_species_summary, aes(x = Species, y = RMSE)) +
  geom_boxplot(fill = "lightblue", alpha = 0.7) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "RMSE Distribution by Species",
    subtitle = "From combined uncertainty analysis",
    x = "Species",
    y = "RMSE"
  )
print(p_species_rmse)
ggsave("plots/rmse_by_species_boxplot_flex_erepro_catchSD_0.5_abSD_2.png", p_species_rmse,
       width = 12, height = 6, dpi = 300)

# Calculate correlation between parameters and RMSE
param_rmse_correlation <- data.frame(
  catchability = sapply(combined_uncertainty_results$parameters,
                       function(x) mean(x$catchability)),
  mammal_scaling = sapply(combined_uncertainty_results$parameters,
                         function(x) mean(x$marine_mammal_scaling)),
  rmse = optimal_results$all_rmse
)

cor_matrix <- cor(param_rmse_correlation)
cat("\n=== Parameter-RMSE Correlations ===\n")
print(cor_matrix)

# Create a heatmap of correlations
require(corrplot)
png("plots/parameter_rmse_correlation_flex_erepro_catchSD_0.5_abSD_2.png", width = 800, height = 600)
corrplot(cor_matrix, method = "color", type = "upper",
         addCoef.col = "black", tl.col = "black", tl.srt = 45,
         title = "Parameter-RMSE Correlations")
dev.off()
```

## Export Optimal Parameters for Future Use

```{r export-optimal-params, eval=FALSE}
# Extract optimal parameters for future simulations
optimal_params_export <- params_1841_2010_fishing_only

# Update with optimal catchability
gear_df <- gear_params(optimal_params_export)
gear_df$catchability <- optimal_results$optimal_params$catchability
gear_params(optimal_params_export) <- gear_df

# Update with optimal marine mammal scaling
sp_params <- species_params(optimal_params_export)
mammal_indices <- which(sp_params$species %in% optimal_results$optimal_params$marine_mammal_species)
for (i in seq_along(mammal_indices)) {
  optimal_params_export@initial_n[mammal_indices[i],] <-
    optimal_params_export@initial_n[mammal_indices[i],] *
    optimal_results$optimal_params$marine_mammal_scaling[i]
}

# Run to steady state (preserving erepro if needed)
# Check if we want to preserve erepro based on the original analysis
preserve_erepro_export <- TRUE  # Set this based on your preference
if (preserve_erepro_export) {
  optimal_params_export <- steady(optimal_params_export, tol = 0.01, t_max = 500, preserve = c("erepro"))
} else {
  optimal_params_export <- steady(optimal_params_export, tol = 0.01, t_max = 500)
  # Check final erepro values
  final_erepro <- species_params(optimal_params_export)$erepro
  if (any(final_erepro > 1, na.rm = TRUE)) {
    warning("Some species have erepro > 1 in the optimal parameters:")
    print(data.frame(
      Species = sp_params$species[which(final_erepro > 1)],
      erepro = final_erepro[which(final_erepro > 1)]
    ))
  }
}

# Save optimal parameters
saveRDS(optimal_params_export, "params_optimal_combined_uncertainty.RDS")

cat("\nOptimal parameters saved to 'params_optimal_combined_uncertainty.RDS'\n")
```
## Adaptive Uncertainty Analysis with Species-Specific Refinement

This section implements an improved adaptive approach that checks RMSE every 10 simulations and refines the parameter search space based on performance, with special attention to species with poor fits.

### Run Adaptive Uncertainty Analysis

The adaptive approach gradually refines the search space, focusing on parameter combinations that show promise while specifically tracking species that have poor fits (like Antarctic krill and minke whales). All necessary functions are included in Helper_Functions.R.

```{r run-adaptive-analysis, eval=FALSE}
# Load required data if not already loaded
if (!exists("combined_effort_array")) {
  combined_effort_array <- readRDS("effort_array_1841_2010.rds")
}

if (!exists("yield_ts_tidy")) {
  yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")
}

# Run adaptive uncertainty analysis
# This will check RMSE every 10 simulations and refine the search space
adaptive_results <- run_adaptive_uncertainty_analysis(
  params = params_1841_2010_fishing_only,
  n_total_sims = 500,  # Total number of simulations
  check_interval = 10,  # Check and refine every 10 simulations (more frequent updates)
  initial_catchability_sd = 0.3,  # Start with wider search
  initial_abundance_sd = 0.4,  # Start with wider search
  marine_mammal_species = c("minke whales", "orca", "sperm whales", "baleen whales", "shelf and coastal fishes"),
  fished_species = c("antarctic krill", "bathypelagic fishes",
                    "shelf and coastal fishes", "squids", "toothfishes",
                    "minke whales", "orca", "sperm whales", "baleen whales"),
  effort_scen = combined_effort_array,
  yield_obs_data = yield_ts_tidy,
  year_range = c(1961, 2010),
  tol = 0.01,
  t_max = 500,
  spinup_years = 118,
  t_start = 1841,
  sim_years = 170,
  preserve_erepro = TRUE,
  max_erepro = 1,
  convergence_threshold = 0.01,  # Stop refining if improvement < 1%
  n_cores = NULL,  # Use all available cores minus 1
  parallel = TRUE,
  verbose = TRUE  # Show progress and species-specific issues
)

# Validate the adaptive results to ensure all simulations are valid
cat("\nValidating adaptive analysis results...\n")
adaptive_results_cleaned <- validate_simulation_results(adaptive_results, verbose = TRUE)

# Save adaptive results
saveRDS(adaptive_results_cleaned, "adaptive_uncertainty_results.RDS")

# Display summary
cat("\n=== Adaptive Analysis Summary ===\n")
cat("Total simulations:", adaptive_results$optimal$total_simulations, "\n")
cat("Optimal RMSE:", round(adaptive_results$optimal$optimal_rmse, 3), "\n")
cat("RMSE range:", round(range(adaptive_results$all_rmse), 3), "\n")

# Display runtime information
cat("\n=== Runtime Information ===\n")
cat("Total runtime:", round(adaptive_results$optimal$runtime$total_minutes, 1), "minutes\n")
cat("Average time per simulation:", round(adaptive_results$optimal$runtime$avg_time_per_simulation, 1), "seconds\n")
cat("Parallel processing:", ifelse(adaptive_results$optimal$runtime$parallel_used,
                                  paste("YES (", adaptive_results$optimal$runtime$n_cores_used, " cores)", sep=""),
                                  "NO (sequential)"), "\n")

cat("\nSpecies-specific RMSE (best simulation):\n")
best_species_rmse <- adaptive_results$species_rmse[[adaptive_results$optimal$optimal_index]]
for (sp in names(best_species_rmse)) {
  cat("  ", sp, ":", round(best_species_rmse[[sp]], 3), "\n")
}
```

### Visualize Adaptive Convergence

```{r visualize-adaptive-convergence, eval=FALSE}
# Plot convergence history
p_convergence <- plot_adaptive_convergence(adaptive_results)
ggsave("plots/adaptive_convergence_history.png", p_convergence,
       width = 12, height = 14, dpi = 300)

# Plot species-specific RMSE evolution
# Focus on problematic species
p_species_evolution <- plot_species_rmse_evolution(
  adaptive_results,
  species_focus = c("antarctic_krill", "minke_whales", "baleen_whales", "sperm_whales")
)
print(p_species_evolution)
ggsave("plots/species_rmse_evolution.png", p_species_evolution,
       width = 14, height = 10, dpi = 300)

# Plot all species RMSE evolution
p_all_species <- plot_species_rmse_evolution(adaptive_results)
ggsave("plots/all_species_rmse_evolution.png", p_all_species,
       width = 16, height = 12, dpi = 300)
```

### Analyze Parameter Correlations

```{r analyze-adaptive-parameters, eval=FALSE}
# Create correlation heatmap for top performers
cor_matrix <- plot_parameter_correlations(adaptive_results, top_percent = 0.1)

# Extract optimal parameters
optimal_params_adaptive <- adaptive_results$optimal$optimal_parameters
cat("\n=== Optimal Parameters from Adaptive Search ===\n")
cat("Catchability values:\n")
print(optimal_params_adaptive$catchability)
cat("\nMarine mammal scaling factors:\n")
mm_scaling_df <- data.frame(
  Species = optimal_params_adaptive$marine_mammal_species,
  Scaling = optimal_params_adaptive$marine_mammal_scaling
)
print(mm_scaling_df)

# Compare with initial parameters
cat("\n=== Parameter Changes from Initial ===\n")
cat("Catchability changes:\n")
print(optimal_params_adaptive$catchability_change)
```

### Compare Adaptive vs. Standard Approach

```{r compare-approaches, eval=FALSE}
# Load standard approach results if available
if (file.exists("combined_uncertainty_results.RDS")) {
  standard_results <- readRDS("combined_uncertainty_results.RDS")
  
  # Compare RMSE distributions
  df_comparison <- data.frame(
    RMSE = c(adaptive_results$all_rmse,
             sapply(standard_results$simulations, function(sim) {
               calculate_yield_rmse(sim, yield_ts_tidy,
                                  species_list = c("antarctic krill", "bathypelagic fishes",
                                                  "shelf and coastal fishes", "squids", "toothfishes",
                                                  "minke whales", "orca", "sperm whales", "baleen whales"),
                                  year_range = c(1961, 2010))$total_rmse
             })),
    Method = c(rep("Adaptive", length(adaptive_results$all_rmse)),
              rep("Standard", length(standard_results$simulations)))
  )
  
  p_comparison <- ggplot(df_comparison, aes(x = Method, y = RMSE, fill = Method)) +
    geom_boxplot(alpha = 0.7) +
    geom_point(position = position_jitter(width = 0.2), alpha = 0.3) +
    scale_fill_manual(values = c("Adaptive" = "darkgreen", "Standard" = "steelblue")) +
    theme_bw() +
    labs(title = "RMSE Comparison: Adaptive vs. Standard Uncertainty Analysis",
         subtitle = "Adaptive approach refines search space every 50 simulations",
         y = "RMSE") +
    theme(legend.position = "none")
  
  print(p_comparison)
  ggsave("plots/adaptive_vs_standard_comparison.png", p_comparison,
         width = 8, height = 6, dpi = 300)
  
  # Statistical comparison
  cat("\n=== Statistical Comparison ===\n")
  cat("Adaptive - Min RMSE:", round(min(adaptive_results$all_rmse), 3), "\n")
  cat("Standard - Min RMSE:", round(min(df_comparison$RMSE[df_comparison$Method == "Standard"]), 3), "\n")
  cat("Improvement:",
      round((min(df_comparison$RMSE[df_comparison$Method == "Standard"]) -
             min(adaptive_results$all_rmse)) /
            min(df_comparison$RMSE[df_comparison$Method == "Standard"]) * 100, 1), "%\n")
  
  # Compare runtimes if available
  if (!is.null(adaptive_results$optimal$runtime)) {
    cat("\n=== Runtime Comparison ===\n")
    cat("Adaptive approach runtime:", round(adaptive_results$optimal$runtime$total_minutes, 1), "minutes\n")
    cat("Time per simulation:", round(adaptive_results$optimal$runtime$avg_time_per_simulation, 1), "seconds\n")
    cat("Efficiency note: Adaptive approach focuses computational effort on promising regions\n")
  }
}
```

### Apply Optimal Parameters from Adaptive Search

```{r apply-adaptive-optimal, eval=FALSE}
# Extract and apply optimal parameters
optimal_sim_adaptive <- adaptive_results$optimal$optimal_simulation

# Plot yield comparison with observations
p_yield_adaptive <- plotYield(optimal_sim_adaptive) +
  facet_wrap(~Species, scales = "free_y") +
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield, colour = Species),
             size = 1) +
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield),
             shape = 1, size = 1, colour = "black") +
  geom_vline(aes(xintercept = 1961), linetype = "dotted", alpha = 0.7) +
  geom_vline(aes(xintercept = 2010), linetype = "dotted", alpha = 0.7) +
  theme_bw() +
  theme(legend.position = "none") +
  labs(title = "Optimal Simulation from Adaptive Search",
       subtitle = paste("RMSE =", round(adaptive_results$optimal$optimal_rmse, 3)))

print(p_yield_adaptive)
ggsave("plots/adaptive_optimal_yield.png", p_yield_adaptive,
       width = 14, height = 10, dpi = 300)

# Create detailed species-specific comparison plots
species_focus <- c("antarctic krill", "minke whales")
for (sp in species_focus) {
  # Get modeled yield for this species
  mod_yield <- getYield(optimal_sim_adaptive)
  df_mod <- reshape2::melt(mod_yield)
  names(df_mod) <- c("Year", "Species", "Yield")
  df_mod_sp <- df_mod[df_mod$Species == sp, ]
  
  # Get observed yield for this species
  obs_sp <- yield_ts_tidy[yield_ts_tidy$Species == sp, ]
  
  p_sp <- ggplot() +
    geom_line(data = df_mod_sp, aes(x = Year, y = Yield),
              color = "darkblue", size = 1.2) +
    geom_point(data = obs_sp, aes(x = Year, y = Yield),
               color = "red", size = 2) +
    theme_bw() +
    labs(title = paste("Adaptive Optimization Result:", sp),
         subtitle = paste("RMSE =", round(best_species_rmse[[sp]], 3)),
         x = "Year", y = "Yield") +
    geom_vline(xintercept = c(1961, 2010), linetype = "dotted", alpha = 0.5)
  
  print(p_sp)
  ggsave(paste0("plots/adaptive_", gsub(" ", "_", sp), "_comparison.png"),
         p_sp, width = 10, height = 6, dpi = 300)
}
```

### Export Optimal Parameters for Future Use

```{r export-adaptive-optimal, eval=FALSE}
# Create parameter object with optimal values
params_optimal_adaptive <- params_1841_2010_fishing_only

# Apply optimal catchability
gear_df <- gear_params(params_optimal_adaptive)
gear_df$catchability <- optimal_params_adaptive$catchability
gear_params(params_optimal_adaptive) <- gear_df

# Apply optimal marine mammal scaling
sp_params <- species_params(params_optimal_adaptive)
mammal_indices <- which(sp_params$species %in% optimal_params_adaptive$marine_mammal_species)
for (i in seq_along(mammal_indices)) {
  params_optimal_adaptive@initial_n[mammal_indices[i],] <-
    params_optimal_adaptive@initial_n[mammal_indices[i],] *
    optimal_params_adaptive$marine_mammal_scaling[i]
}

# Run to steady state
params_optimal_adaptive <- steady(params_optimal_adaptive,
                                 tol = 0.01,
                                 t_max = 500,
                                 preserve = c("erepro"))

# Save optimal parameters
saveRDS(params_optimal_adaptive, "params_optimal_adaptive.RDS")
cat("\nOptimal parameters from adaptive search saved to 'params_optimal_adaptive.RDS'\n")
```

## Conclusions

This enhanced adaptive uncertainty assessment provides several key improvements:

1. **Adaptive Parameter Refinement**: The search space is refined every 50 simulations based on performance, allowing the algorithm to focus on promising parameter regions
2. **Species-Specific Tracking**: Individual species RMSE is monitored throughout, identifying problematic species (like Antarctic krill and minke whales) that need special attention
3. **Convergence Monitoring**: The algorithm tracks convergence and can automatically reduce search space when improvements plateau
4. **Efficient Search**: By gradually narrowing the search space, the adaptive approach finds better solutions with fewer simulations
5. **Targeted Optimization**: The algorithm biases search towards regions that show promise, improving efficiency

The adaptive approach specifically addresses the issue of species with poor fits by:
- Tracking their individual RMSE throughout the optimization
- Identifying when certain species consistently have high errors
- Adjusting the search strategy to improve these specific fits
- Providing detailed diagnostics about which species are problematic

This method is particularly effective for complex models where different species may require different scaling factors or catchability adjustments to match observed data.


