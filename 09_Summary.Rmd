---
title: "R Notebook"
output: html_notebook
---

Do I need contant phytoplankton and temperature forcings for any spin-up, like if we need to use steady() in a loop testing parameter uncertaitny?

Also need to make sure initial effort is zero for the repreated forcing during a spin-up like above 

# Load helper functions

Some useful plotting functions for modelled versus observed yield (timeseries) and biomass (mean decadal value for 2010-2020)
```{r}
source("Helper_Functions.R")
```


```{r}
library(therMizer)
library(mizer)
library(tidyverse)
```


# Load params
Best version of Pyrdz Bay mizer model parameters at steady-state for the contemporary ecosystem 2010 - 2020
```{r}
params_new_v4 <- readRDS("params_steady_state_2011_2020_tol_0.00025.RDS")

combined_effort_array <- readRDS("effort_array_1841_2010.rds")
```

# Load climate forcings

The temperature and phytoplankton climate forcings for the ISIMIP3a protocol for Prydz Bay region
In some cases we need repeated constant values of the first year of these forcings, either for spin-ups or to mimin 'no climate change'. These repeated forcings are created as starting in 1961 and a version that starts in 1841

```{r}
# Temperature
extended_ocean_temp <- readRDS("temperature_forcing_1841_2010.rds")
constant_array_temp <- readRDS("constant_array_temp.RDS")
constant_array_temp_1841 <- readRDS("constant_array_temp_1841.RDS")

# Phytoplankton
extended_n_pp_array <- readRDS("phytoplankton_forcing_1841_2010.rds")
constant_array_n_pp <- readRDS("constant_array_n_pp.RDS")
constant_array_n_pp_1841 <- readRDS("constant_array_n_pp_1841.RDS")
```

# Setup params

```{r}
params_1841_2010_climate_only <- upgradeTherParams(params_new_v4, 
                                                   ocean_temp_array = extended_ocean_temp,
                                                   n_pp_array = extended_n_pp_array,
                                                   # vertical_migration_array = vertical_migration_array,
                                                   # exposure_array = ESS_exposure,
                                                   aerobic_effect = FALSE, metabolism_effect = TRUE)


params_1841_2010_fishing_only <- upgradeTherParams(params_new_v4, 
                                                   ocean_temp_array = constant_array_temp_1841,
                                                   n_pp_array = constant_array_n_pp_1841,
                                                   # vertical_migration_array = vertical_migration_array,
                                                   # exposure_array = ESS_exposure,
                                                   aerobic_effect = FALSE, metabolism_effect = TRUE)


```

# Run simulations

```{r}
sim_1841_2010_climate_only_spinup <- project(params_1841_2010_climate_only, 
                                             t_start = 1841, 
                                             t_max = 118,  
                                             effort = 0)
```


```{r}
sim_1841_2010_climate_only <- project(params_1841_2010_climate_only,
                                      initial_n=sim_1841_2010_climate_only_spinup@n[118,,], 
                                      t_start = 1841, 
                                      t_max = 170,  
                                      effort = 0)
```


```{r}
sim_1841_2010_fishing_only <- project(params_1841_2010_fishing_only,
                                      initial_n=sim_1841_2010_climate_only_spinup@n[118,,],
                                      t_start = 1841, 
                                      t_max = 170,  
                                      effort = combined_effort_array)
```


```{r}
sim_1841_2010_climate_and_fishing <- project(params_1841_2010_climate_only,
                                             initial_n=sim_1841_2010_climate_only_spinup@n[118,,],
                                             t_start = 1841, 
                                             t_max = 170,  
                                             effort = combined_effort_array)
```





# Size spectrum

```{r}
mizerExperimental::plotSpectra2(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1841:1860)
mizerExperimental::plotSpectra2(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1940:1950)
mizerExperimental::plotSpectra2(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 2000:2010)

plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1920:1930)
plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1930:1940)
plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 1940:1950)
plotSpectraRelative(sim_1841_2010_climate_only, sim_1841_2010_fishing_only, time_range = 2000:2010)
```


# Inspect biomass time series

```{r}
plot_biomass_comparison(sim_1841_2010_fishing_only)
```

# Inspect yield time series

```{r}
yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")

plot_yield_comparison(sim_1841_2010_fishing_only, 
                      yield_ts_tidy,
                      free_y_scale = F)
```


# Catchability uncertainty

Catchability for the fished groups is uncertain.
We want to explore the parameter space around catchability values for the fished groups to understand how that affects the modelled versus observed yield


```{r}
# Function to randomize catchability only for fished species
randomize_catchability <- function(params, sdev = 0.1) {
  # Get current gear parameters
  gear_df <- gear_params(params)
  
  # Check if there's fishing happening (non-zero catchability)
  if(nrow(gear_df) > 0) {
    # Generate noise for each catchability value
    for(i in 1:nrow(gear_df)) {
      # Only add noise if catchability is non-zero (meaning it's fished)
      if(gear_df$catchability[i] > 0) {
        # Generate random noise
        noise <- rnorm(1, mean = 0, sd = sdev)
        
        # Apply noise to catchability
        gear_df$catchability[i] <- gear_df$catchability[i] * exp(noise)
        
        # Ensure values stay between 0 and 1
        if(gear_df$catchability[i] > 1) gear_df$catchability[i] <- 1
        if(gear_df$catchability[i] < 0) gear_df$catchability[i] <- 0
      }
    }
    
    # Update parameters with new catchability values
    
    gear_params(params) <- gear_df
    
  }
  
  return(params)
}

# Function to run multiple simulations with randomized catchability for fished species
run_random_catchability_sims <- function(params, 
                                         n_sims = 10, 
                                         years = 170, 
                                         sd = 0.1, 
                                         effort_scen, 
                                         tol = .01,
                                         t_max = 500) {
  # List to store simulation results
  sim_results <- list()
  
  # Run simulations
  for(i in 1:n_sims) {
    # Create new parameters with randomized catchability
    rand_params <- randomize_catchability(params, sd = sd)
    
    # Run to steady state
    rand_params <- steady(rand_params, tol = tol, t_max = t_max)
    
    # Run simulation with provided effort scenario
    sim <- project(rand_params, effort = effort_scen)
    
    # Store results
    sim_results[[i]] <- sim
  }
  
  return(sim_results)
}
```


```{r}
#Orignal run
sim0 <- project(params_1841_2010_climate_only, effort = combined_effort_array)

plotlyBiomass(sim0)
plotYield(sim0)

# Run single simulation with randomized matrix as a test
rand_params <- randomize_catchability(params_1841_2010_climate_only)
sim1 <- project(rand_params,effort = combined_effort_array)

plotBiomassRelative(sim1,sim0)

# Run multiple simulations

# 9th July 2025 - try dramatically increasing the SD for catachability variation 
sims_scen4 <- run_random_catchability_sims(params_1841_2010_climate_only, n_sims = 100, effort_scen = combined_effort_array, sd = 2)



# Save sim outputs

saveRDS(sims_scen4,"sims_scen4.RDS")


# read in biomass and catches data

```


```{r}

# New facet label names for species
species.labs <- c("Antarctic krill", "Bathypelagic fishes", "Shelf & Coastal fishes", "Squids", "Toothfishes", "Antarctic minke whales", "Orcas", "Sperm whales", "Baleen whales")
names(species.labs) <- c("antarctic krill", "bathypelagic fishes", "shelf and coastal fishes", "squids", "toothfishes", "minke whales", "orca", "sperm whales", "baleen whales")

##############
# Figure for CATCHES 

trimYield<-function(sim){
  
  y<-plotYieldGear(sim, return_data = T)
  y<-select(y,c(Year, Species,Yield))
  return(y)
  
}

sim_catches<-lapply(sims_scen4,trimYield)
for (i in 1:100) {
  sim_catches[[i]]$sim<-i
}

df_sim_catch<-do.call(rbind.data.frame, sim_catches)

sim_mean_c<-df_sim_catch |>  group_by(Species,Year) |>summarise(Yield=median(Yield))|> ungroup()
sim_lower_c<-df_sim_catch |> group_by(Species,Year) |>summarise(Yield=min(Yield))|> ungroup() 
sim_upper_c<-df_sim_catch |> group_by(Species,Year)|>summarise(Yield=max(Yield))|> ungroup() 

sim1_c <-data.frame(Species=sim_mean_c$Species, 
                  Year=sim_mean_c$Year,
                  sim_mean=sim_mean_c$Yield,
                  sim_lower=sim_lower_c$Yield,
                  sim_upper=sim_upper_c$Yield)

sim1_c <-right_join(yield_ts,sim1_c)

# Plot

ggplot(sim1_c, aes(x=Year, y=Yield, colour=Species)) +
  facet_wrap(~Species, scales="free_y") +
  geom_point(aes(y=Yield), colour="black", size=0.5) +
  geom_ribbon(data = sim1_c, 
              aes(ymin=sim_lower, ymax=sim_upper), alpha=0.3, colour=NA) +
  geom_line(data = sim1_c, 
            aes(y=sim_mean,colour=Species)) +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.title.x = element_blank())

  p_yield <- plotYield(sim_1841_2010_fishing_only) + 
  facet_wrap(~Species,
             labeller = labeller(Species = species.labs)) +
  labs(fill = "Functional group") +
  # facet_wrap(~Species,scales="free_y") +
  geom_point(data = yield_ts_tidy, aes(x = Year, y = Yield, colour = Species), size=1) +
  geom_point(data = yield_ts_tidy, aes(x = Year, y = Yield), shape = 1,size = 1,colour = "black") +
  geom_ribbon(data = sim1_c, aes(x = Year, y=Yield, ymin=sim_lower, ymax=sim_upper), alpha=0.3, colour=NA) +
  theme(legend.title = element_text( size=3), legend.text=element_text(size=3)) + 
  geom_vline(aes(xintercept = 1961), linetype = "dashed") + 
  geom_vline(aes(xintercept = 2010), linetype = "dashed") +
  # scale_x_continuous(breaks = c(1930,1945,1961,1985,2010)) +
  # scale_y_log10() +
  theme_bw() +
  theme(
    legend.position = "none"
  )
  
p_yield

# ggsave("plots/Catchability_v1_Yield_1841_2010.tiff", plot = p_yield, units="cm", width=22, height=16, dpi =300)
```



# Scale initial abundances

We developed a steady-state model for the contemporary time period (2010-2020), but we are now assessing the historical change in biomass and yield. Thinking about the implication of historical whaling in particular, we need to explore how different initial steady-states would influence how biomass, yield and size structure change over time by exploring what initial conditions would need to be to best fit the yield timeseries and the mean value observed biomass for 2010-2020.

## Simple manual scaling example
Increase initial abundance of whales using the new helper functions
```{r}
# Setup base parameters with climate forcings
params_1841_2010_climate_only <- upgradeTherParams(params_new_v4,
                                                   ocean_temp_array = extended_ocean_temp,
                                                   n_pp_array = extended_n_pp_array,
                                                   # vertical_migration_array = vertical_migration_array,
                                                   # exposure_array = ESS_exposure,
                                                   aerobic_effect = FALSE, metabolism_effect = TRUE)

# Use the new scaling function for marine mammals
# Scaling factors: minke whales (50x), orca (5x), sperm whales (50x), baleen whales (50x)
scaling_factors <- c(50, 5, 50, 50)
marine_mammal_species <- c("minke whales", "orca", "sperm whales", "baleen whales")

params_scaled_v1 <- scale_marine_mammal_abundance(params_1841_2010_climate_only,
                                                  scaling_factors = scaling_factors,
                                                  species_to_scale = marine_mammal_species)

# Run to steady state
params_scaled_v1 <- steady(params_scaled_v1,
                           t_max = 500,
                           tol = 0.01,
                           preserve = c("erepro"))

species_params(params_scaled_v1)$erepro
plot(params_scaled_v1)
```

```{r}
sim_scaled_spinup <- project(params_scaled_v1, 
                             t_start = 1841,
                             t_max = 118,
                             effort = 0)
```

```{r}
sim_scaled_climate_only <- project(params_scaled_v1,
                                      initial_n=sim_scaled_spinup@n[118,,], 
                                      t_start = 1841, 
                                      t_max = 170,  
                                      effort = 0)
```

```{r}
sim_scaled_climate_and_fishing <- project(params_scaled_v1,
                                             initial_n=sim_scaled_spinup@n[118,,],
                                             t_start = 1841, 
                                             t_max = 170,  
                                             effort = combined_effort_array)
```

# Inspect biomass time series

```{r}
plot_biomass_comparison(sim_scaled_climate_only)
plot_biomass_comparison(sim_scaled_climate_and_fishing)
```
# Combined Catchability and Abundance Scaling Uncertainty Assessment

This section implements a comprehensive uncertainty assessment that combines both catchability uncertainty for fished species and abundance scaling uncertainty for marine mammals. This approach allows us to explore the parameter space more thoroughly and find optimal parameter combinations that best match observed data.

**Key improvements incorporated from optimization scripts 11/12:**
- **Enhanced whale prioritization**: Whale species receive much higher weighting (5-10x) in fit evaluation
- **Additional performance metrics**: Beyond RMSE, includes MAE, bias, correlation, and relative error
- **Stricter steady-state criteria**: Minimum 1000 years t_max, tolerance ≤ 0.002
- **Enhanced spin-up protocol**: Multiple spin-up cycles with biomass stability validation
- **Biomass stability tolerance**: Final 50 years CV must be < 5% for stable simulations

## Setup for Combined Uncertainty Analysis

```{r combined-uncertainty-setup}
# Load required libraries for parallel processing
library(parallel)
library(doParallel)
library(foreach)

# Define species-specific weights emphasizing whale groups
species_weights <- data.frame(
  Species = c("minke whales", "sperm whales", "baleen whales", "orca",
             "antarctic krill", "bathypelagic fishes", "shelf and coastal fishes",
             "squids", "toothfishes"),
  weight = c(5,      # minke whales - high priority
            10,     # sperm whales - highest priority (worst fit historically)
            8,      # baleen whales - very high priority
            3,      # orca - moderate priority
            1,      # krill - standard (good fit already)
            1,      # bathypelagic - standard (good fit already)
            1,      # shelf/coastal - standard (good fit already)
            1,      # squids - standard
            1)      # toothfish - standard
)

cat("=== SPECIES WEIGHTING STRATEGY ===\n")
print(species_weights)
cat("Whale species receive 3-10x higher weighting for model fit evaluation\n\n")

# Enhanced biomass stability check function with diagnostics
check_biomass_stability_enhanced <- function(sim_object, tolerance = 0.05, check_years = 50, 
                                            verbose = FALSE, sim_id = NULL) {
  # Check the coefficient of variation for the last check_years
  biomass <- getBiomass(sim_object)
  
  if (nrow(biomass) < check_years) {
    if (verbose && !is.null(sim_id)) {
      cat("Sim", sim_id, ": Insufficient data (", nrow(biomass), "years < ", check_years, "required)\n")
    }
    return(list(stable = FALSE, reason = "insufficient_data", cv_values = NULL))
  }
  
  # Get last check_years of data
  recent_biomass <- tail(biomass, check_years)
  
  # Calculate CV for each species
  cv_by_species <- apply(recent_biomass, 2, function(x) {
    if (mean(x) == 0) return(Inf)
    sd(x) / mean(x)
  })
  
  # Check if all species have CV below tolerance
  all_stable <- all(cv_by_species < tolerance, na.rm = TRUE)
  
  # Detailed diagnostics
  if (verbose && !is.null(sim_id)) {
    cat("Sim", sim_id, "stability check:\n")
    cat("  - Tolerance:", tolerance * 100, "% CV\n")
    cat("  - Check period: last", check_years, "years\n")
    
    unstable_species <- names(cv_by_species)[cv_by_species >= tolerance]
    stable_species <- names(cv_by_species)[cv_by_species < tolerance]
    
    if (length(unstable_species) > 0) {
      cat("  - UNSTABLE (", length(unstable_species), "/", length(cv_by_species), "): ")
      for (sp in unstable_species) {
        cat(sp, "(", round(cv_by_species[sp] * 100, 1), "%) ")
      }
      cat("\n")
    }
    
    if (length(stable_species) > 0) {
      cat("  - Stable (", length(stable_species), "/", length(cv_by_species), "): ")
      for (sp in stable_species) {
        cat(sp, "(", round(cv_by_species[sp] * 100, 1), "%) ")
      }
      cat("\n")
    }
  }
  
  # Return detailed results for non-verbose calls
  if (!verbose) {
    return(all_stable)
  } else {
    return(list(
      stable = all_stable,
      cv_values = cv_by_species,
      n_stable = sum(cv_by_species < tolerance, na.rm = TRUE),
      n_unstable = sum(cv_by_species >= tolerance, na.rm = TRUE),
      worst_cv = max(cv_by_species, na.rm = TRUE),
      worst_species = names(cv_by_species)[which.max(cv_by_species)]
    ))
  }
}

# Enhanced steady-state function with stricter criteria and diagnostics
enhanced_steady_state <- function(params, 
                                  tol = 0.002,           # Stricter tolerance
                                  t_max = 1000,          # Minimum 1000 years
                                  preserve_erepro = TRUE,
                                  max_attempts = 3,
                                  verbose = FALSE,
                                  sim_id = NULL) {
  
  attempt <- 1
  steady_successful <- FALSE
  original_t_max <- t_max
  
  while (attempt <= max_attempts && !steady_successful) {
    if (verbose && !is.null(sim_id)) {
      cat("Sim", sim_id, "steady-state attempt", attempt, "of", max_attempts, 
          "(tol =", tol, ", t_max =", t_max, ")\n")
    }
    
    tryCatch({
      if (preserve_erepro) {
        params_steady <- steady(params, tol = tol, t_max = t_max, preserve = c("erepro"))
      } else {
        params_steady <- steady(params, tol = tol, t_max = t_max)
      }
      
      # Validate steady state by running a longer simulation consistent with spinup requirements
      test_sim <- project(params_steady, t_max = 118, effort = 0)  # Use minimum spinup length
      stability_check <- check_biomass_stability_enhanced(test_sim, tolerance = 0.10,  # 10% CV tolerance
                                                         check_years = 20, verbose = FALSE)
      
      if (is.logical(stability_check) && stability_check) {
        if (verbose && !is.null(sim_id)) {
          cat("Sim", sim_id, "steady-state achieved and validated (attempt", attempt, ")\n")
        }
        steady_successful <- TRUE
        return(params_steady)
      } else {
        if (verbose && !is.null(sim_id)) {
          cat("Sim", sim_id, "steady-state converged but not stable (attempt", attempt, ")\n")
        }
        
        # Instead of just increasing t_max, make small parameter adjustments
        # This gives the system a chance to find a more stable configuration
        if (attempt < max_attempts) {
          # Make small random adjustments to abundance to help find stability
          sp_params <- species_params(params)
          for (i in 1:nrow(sp_params)) {
            if (runif(1) < 0.3) {  # 30% chance to adjust each species
              adjustment <- runif(1, 0.95, 1.05)  # ±5% adjustment
              params@initial_n[i,] <- params@initial_n[i,] * adjustment
            }
          }
          t_max <- original_t_max  # Reset t_max since we're trying new parameters
        }
      }
    }, error = function(e) {
      if (verbose && !is.null(sim_id)) {
        cat("Sim", sim_id, "steady-state failed:", e$message, "\nTrying again with parameter adjustment\n")
      }
      # Small parameter adjustment on error too
      if (attempt < max_attempts) {
        sp_params <- species_params(params)
        for (i in 1:nrow(sp_params)) {
          if (runif(1) < 0.2) {  # 20% chance to adjust each species
            adjustment <- runif(1, 0.98, 1.02)  # ±2% adjustment
            params@initial_n[i,] <- params@initial_n[i,] * adjustment
          }
        }
      }
    })
    
    attempt <- attempt + 1
  }
  
  # If all attempts failed, return original params with warning
  if (verbose && !is.null(sim_id)) {
    cat("Sim", sim_id, "steady-state failed after", max_attempts, "attempts. Using original parameters.\n")
  }
  return(list(params = params, steady_failed = TRUE))
}

# Enhanced spin-up function with multiple cycles and stability checks
enhanced_spinup <- function(params,
                           spinup_years = 118,
                           spinup_multiplier = 1,    # Can be 2, 3, or 4 for extended spinup
                           effort_scenario,
                           stability_tolerance = 0.10,  # Updated default to 10% based on test results
                           t_start = 1841,
                           final_years = 170,
                           verbose = FALSE,
                           sim_id = NULL) {
  
  total_spinup_years <- spinup_years * spinup_multiplier
  if (verbose && !is.null(sim_id)) {
    cat("Sim", sim_id, "running enhanced spinup for", total_spinup_years, "years (", 
        spinup_multiplier, "x base period)\n")
  }
  
  # Step 1: Initial spinup without fishing
  sim_spinup <- project(params, 
                       t_start = t_start, 
                       t_max = total_spinup_years,
                       effort = 0)
  
  # Step 2: Check biomass stability during spinup (NO FISHING PERIOD)
  # This is the key fix - we check stability on the spinup simulation, not the final one
  spinup_stability_check <- check_biomass_stability_enhanced(sim_spinup, 
                                                            tolerance = stability_tolerance, 
                                                            check_years = min(50, total_spinup_years),
                                                            verbose = verbose,
                                                            sim_id = sim_id)
  
  # Handle both return formats
  if (is.list(spinup_stability_check)) {
    is_stable <- spinup_stability_check$stable
  } else {
    is_stable <- spinup_stability_check
  }
  
  if (!is_stable) {
    if (verbose && !is.null(sim_id)) {
      cat("Sim", sim_id, "spinup not stable, extending by 50%\n")
    }
    # Extend spinup if not stable
    extended_spinup <- project(params,
                              initial_n = sim_spinup@n[total_spinup_years,,],
                              t_start = t_start + total_spinup_years,
                              t_max = round(total_spinup_years * 0.5),
                              effort = 0)
    
    # Check stability of extended spinup
    extended_stability_check <- check_biomass_stability_enhanced(extended_spinup, 
                                                                tolerance = stability_tolerance, 
                                                                check_years = min(30, round(total_spinup_years * 0.5)),
                                                                verbose = verbose,
                                                                sim_id = sim_id)
    
    if (is.list(extended_stability_check)) {
      is_stable <- extended_stability_check$stable
    } else {
      is_stable <- extended_stability_check
    }
    
    final_initial_n <- extended_spinup@n[round(total_spinup_years * 0.5),,]
  } else {
    if (verbose && !is.null(sim_id)) {
      cat("Sim", sim_id, "spinup achieved stability\n")
    }
    final_initial_n <- sim_spinup@n[total_spinup_years,,]
  }
  
  # Step 3: Run main simulation with fishing effort
  # This simulation will have variability due to fishing - that's expected and normal!
  sim_final <- project(params,
                      initial_n = final_initial_n,
                      t_start = t_start,
                      t_max = final_years,
                      effort = effort_scenario)
  
  return(list(
    simulation = sim_final,
    spinup_stable = is_stable,
    final_initial_n = final_initial_n,
    spinup_simulation = sim_spinup  # Return spinup sim for diagnostics if needed
  ))
}

# Enhanced model performance evaluation with multiple metrics
calculate_enhanced_performance_metrics <- function(sim_object,
                                                  yield_obs_data,
                                                  species_weights_df = species_weights,
                                                  species_list = NULL,
                                                  year_range = NULL) {
  
  # Get modeled yield
  mod_yield <- getYield(sim_object)
  df_mod <- reshape2::melt(mod_yield)
  names(df_mod) <- c("Year", "Species", "Yield")
  
  # Filter by year range and species if specified
  if (!is.null(year_range)) {
    df_mod <- df_mod[df_mod$Year >= min(year_range) & df_mod$Year <= max(year_range), ]
    yield_obs_data <- yield_obs_data[yield_obs_data$Year >= min(year_range) &
                                     yield_obs_data$Year <= max(year_range), ]
  }
  
  if (!is.null(species_list)) {
    df_mod <- df_mod[df_mod$Species %in% species_list, ]
    yield_obs_data <- yield_obs_data[yield_obs_data$Species %in% species_list, ]
  }
  
  # Merge modeled and observed data
  comparison <- merge(df_mod, yield_obs_data,
                     by = c("Year", "Species"),
                     suffixes = c("_mod", "_obs"))
  
  # Calculate comprehensive metrics by species
  metrics_by_species <- comparison %>%
    group_by(Species) %>%
    summarise(
      RMSE = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)),
      MAE = mean(abs(Yield_mod - Yield_obs), na.rm = TRUE),
      Mean_Obs = mean(Yield_obs, na.rm = TRUE),
      Mean_Mod = mean(Yield_mod, na.rm = TRUE),
      Bias = mean(Yield_mod - Yield_obs, na.rm = TRUE),
      Relative_Error = sqrt(mean((Yield_mod - Yield_obs)^2, na.rm = TRUE)) / mean(Yield_obs, na.rm = TRUE) * 100,
      Correlation = cor(Yield_mod, Yield_obs, use = "complete.obs"),
      MAPE = mean(abs((Yield_mod - Yield_obs) / Yield_obs), na.rm = TRUE) * 100,
      n_obs = n(),
      .groups = 'drop'
    )
  
  # Apply species weights and calculate weighted metrics
  metrics_weighted <- metrics_by_species %>%
    left_join(species_weights_df, by = "Species") %>%
    mutate(weight = ifelse(is.na(weight), 1, weight)) # Default weight of 1 for unspecified species
  
  # Calculate weighted overall metrics
  total_weighted_rmse <- weighted.mean(metrics_weighted$RMSE, 
                                       metrics_weighted$weight * metrics_weighted$n_obs, 
                                       na.rm = TRUE)
  
  total_weighted_mae <- weighted.mean(metrics_weighted$MAE,
                                      metrics_weighted$weight * metrics_weighted$n_obs,
                                      na.rm = TRUE)
  
  total_weighted_bias <- weighted.mean(metrics_weighted$Bias,
                                       metrics_weighted$weight * metrics_weighted$n_obs,
                                       na.rm = TRUE)
  
  avg_correlation <- mean(metrics_weighted$Correlation, na.rm = TRUE)
  
  # Calculate composite score (lower is better)
  # Combines multiple metrics with emphasis on RMSE
  composite_score <- (total_weighted_rmse * 0.4) + 
                    (total_weighted_mae * 0.3) + 
                    (abs(total_weighted_bias) * 0.2) + 
                    ((1 - avg_correlation) * 0.1)
  
  return(list(
    total_weighted_rmse = total_weighted_rmse,
    total_weighted_mae = total_weighted_mae,
    total_weighted_bias = total_weighted_bias,
    avg_correlation = avg_correlation,
    composite_score = composite_score,
    metrics_by_species = metrics_by_species,
    metrics_weighted = metrics_weighted,
    comparison_data = comparison
  ))
}

# Function to run a single simulation with enhanced protocols and diagnostics
run_enhanced_single_sim <- function(sim_id, params, catchability_sd, abundance_sd,
                                   marine_mammal_species, effort_scen, 
                                   enhanced_steady_tol, enhanced_steady_t_max,
                                   spinup_years, spinup_multiplier,
                                   t_start, sim_years,
                                   preserve_erepro, max_erepro,
                                   species_weights_df,
                                   yield_obs_data,
                                   verbose = FALSE) {
  
  if (verbose) {
    cat("=== Starting enhanced simulation", sim_id, "===\n")
  }
  
  # Create copy of params
  rand_params <- params
  
  # Step 1: Randomize catchability for fished species
  gear_df <- gear_params(rand_params)
  original_catchability <- gear_df$catchability
  
  if(nrow(gear_df) > 0) {
    for(j in 1:nrow(gear_df)) {
      if(gear_df$catchability[j] > 0) {
        noise <- rnorm(1, mean = 0, sd = catchability_sd)
        gear_df$catchability[j] <- gear_df$catchability[j] * exp(noise)
        gear_df$catchability[j] <- min(1, max(0, gear_df$catchability[j]))
      }
    }
    gear_params(rand_params) <- gear_df
  }
  
  # Step 2: Randomize marine mammal abundance
  sp_params <- species_params(rand_params)
  species_indices <- which(sp_params$species %in% marine_mammal_species)
  scaling_factors <- exp(rnorm(length(species_indices), mean = 0, sd = abundance_sd))
  
  for (k in seq_along(species_indices)) {
    rand_params@initial_n[species_indices[k],] <-
      rand_params@initial_n[species_indices[k],] * scaling_factors[k]
  }
  
  if (verbose) {
    cat("Sim", sim_id, "parameter modifications:\n")
    cat("  - Catchability changes: ", paste(round(gear_df$catchability / original_catchability, 2), collapse = ", "), "\n")
    cat("  - Marine mammal scaling: ", paste(round(scaling_factors, 2), collapse = ", "), "\n")
  }
  
  # Step 3: Enhanced steady state
  steady_result <- enhanced_steady_state(rand_params, 
                                       tol = enhanced_steady_tol,
                                       t_max = enhanced_steady_t_max,
                                       preserve_erepro = preserve_erepro,
                                       verbose = verbose,
                                       sim_id = sim_id)
  
  # Check if steady state failed
  if (is.list(steady_result) && !is.null(steady_result$steady_failed)) {
    return(list(
      success = FALSE,
      reason = "steady_state_failed",
      sim_id = sim_id,
      details = "Could not achieve steady state within max attempts"
    ))
  }
  
  rand_params <- steady_result
  
  # Check erepro if not preserving
  if (!preserve_erepro) {
    current_erepro <- species_params(rand_params)$erepro
    if (any(current_erepro > max_erepro, na.rm = TRUE)) {
      return(list(
        success = FALSE,
        reason = "erepro_exceeded",
        sim_id = sim_id,
        details = paste("Max erepro:", round(max(current_erepro, na.rm = TRUE), 3))
      ))
    }
  }
  
  # Step 4: Enhanced spinup and main simulation
  sim_result <- enhanced_spinup(rand_params,
                               spinup_years = spinup_years,
                               spinup_multiplier = spinup_multiplier,
                               effort_scenario = effort_scen,
                               stability_tolerance = 0.10,  # Use 10% CV threshold for spinup stability
                               t_start = t_start,
                               final_years = sim_years,
                               verbose = verbose,
                               sim_id = sim_id)
  
  # Step 5: Check if spinup achieved stability - this is the only stability check we need!
  # The final simulation with fishing is SUPPOSED to have variability
  if (!sim_result$spinup_stable) {
    return(list(
      success = FALSE,
      reason = "spinup_instability",
      sim_id = sim_id,
      details = "Spinup period did not achieve biomass stability (>10% CV)"
    ))
  }
  
  if (verbose && !is.null(sim_id)) {
    cat("Sim", sim_id, "spinup was stable, simulation completed successfully\n")
  }
  
  # Step 6: Calculate enhanced performance metrics
  performance <- calculate_enhanced_performance_metrics(sim_result$simulation,
                                                       yield_obs_data,
                                                       species_weights_df)
  
  if (verbose) {
    cat("Sim", sim_id, "completed successfully. Composite score:", 
        round(performance$composite_score, 4), "\n")
  }
  
  return(list(
    success = TRUE,
    sim_id = sim_id,
    simulation = sim_result$simulation,
    performance = performance,
    spinup_stable = sim_result$spinup_stable,
    params_info = list(
      sim_id = sim_id,
      catchability = gear_df$catchability,
      catchability_change = gear_df$catchability / original_catchability,
      marine_mammal_scaling = scaling_factors,
      marine_mammal_species = marine_mammal_species[seq_along(scaling_factors)],
      erepro_values = species_params(rand_params)$erepro
    )
  ))
}

# Main function to run enhanced combined uncertainty simulations
run_enhanced_combined_uncertainty_sims <- function(params,
                                                   n_sims = 10,
                                                   catchability_sd = 0.1,
                                                   abundance_sd = 0.2,
                                                   marine_mammal_species = NULL,
                                                   effort_scen,
                                                   enhanced_steady_tol = 0.002,      # Stricter tolerance
                                                   enhanced_steady_t_max = 1000,     # Minimum 1000 years
                                                   spinup_years = 118,
                                                   spinup_multiplier = 2,             # 2x base spinup by default
                                                   t_start = 1841,
                                                   sim_years = 170,
                                                   preserve_erepro = TRUE,
                                                   max_erepro = 1,
                                                   species_weights_df = species_weights,
                                                   yield_obs_data,
                                                   n_cores = NULL,
                                                   parallel = TRUE) {
  
  # Default marine mammal species if not specified
  if (is.null(marine_mammal_species)) {
    marine_mammal_species <- c("minke whales", "orca", "sperm whales", "baleen whales")
  }
  
  # Determine number of cores to use
  if (is.null(n_cores)) {
    n_cores <- detectCores() - 1
  }
  n_cores <- min(n_cores, detectCores())
  
  # Progress message
  cat("=== ENHANCED COMBINED UNCERTAINTY ANALYSIS ===\n")
  cat("Running", n_sims, "simulations with enhanced protocols:\n")
  cat("  - Steady-state tolerance:", enhanced_steady_tol, "\n")
  cat("  - Minimum steady-state time:", enhanced_steady_t_max, "years\n")
  cat("  - Spinup multiplier:", spinup_multiplier, "x (", spinup_years * spinup_multiplier, "years total)\n")
  cat("  - Whale species weighting: 3-10x higher than fish/krill\n")
  cat("  - Performance metrics: RMSE, MAE, Bias, Correlation, Composite Score\n")
  
  if (preserve_erepro) {
    cat("  - Preserving erepro values during steady state\n")
  } else {
    cat("  - Will skip simulations with erepro >", max_erepro, "\n")
  }
  
  if (parallel && n_cores > 1) {
    cat("  - Using parallel processing with", n_cores, "cores\n")
    
    # Set up parallel cluster
    cl <- makeCluster(n_cores)
    registerDoParallel(cl)
    
    # Export necessary objects to cluster
    clusterExport(cl, c("run_enhanced_single_sim", "enhanced_steady_state", 
                       "enhanced_spinup", "check_biomass_stability_enhanced",
                       "calculate_enhanced_performance_metrics", "calculate_yield_rmse",
                       "species_weights_df"), 
                  envir = environment())
    
    # Export yield data for any legacy references in cluster functions
    clusterExport(cl, "yield_obs_data", envir = environment())
    
    # Also create yield_ts_tidy alias in cluster environment for backward compatibility
    clusterEvalQ(cl, {
      yield_ts_tidy <- yield_obs_data
    })
    
    # Run simulations in parallel
    n_attempts <- ifelse(preserve_erepro, n_sims, ceiling(n_sims * 2))
    
    cat("  - Running", n_attempts, "initial attempts...\n")
    
    results <- foreach(i = 1:n_attempts,
                      .packages = c("mizer", "therMizer", "dplyr"),
                      .errorhandling = "pass") %dopar% {
      run_enhanced_single_sim(i, params, catchability_sd, abundance_sd,
                             marine_mammal_species, effort_scen, 
                             enhanced_steady_tol, enhanced_steady_t_max,
                             spinup_years, spinup_multiplier,
                             t_start, sim_years,
                             preserve_erepro, max_erepro,
                             species_weights_df, yield_obs_data)
    }
    
    # Stop cluster
    stopCluster(cl)
    
  } else {
    # Sequential processing
    cat("  - Using sequential processing\n")
    
    n_attempts <- ifelse(preserve_erepro, n_sims, ceiling(n_sims * 2))
    results <- list()
    
    for(i in 1:n_attempts) {
      if(i %% 5 == 0) cat("    Processing simulation", i, "of", n_attempts, "\n")
      
      results[[i]] <- run_enhanced_single_sim(i, params, catchability_sd, abundance_sd,
                                             marine_mammal_species, effort_scen, 
                                             enhanced_steady_tol, enhanced_steady_t_max,
                                             spinup_years, spinup_multiplier,
                                             t_start, sim_years,
                                             preserve_erepro, max_erepro,
                                             species_weights_df, yield_obs_data,
                                             verbose = (i <= 3))  # Verbose for first 3 simulations
    }
  }
  
  # Process results
  sim_results <- list()
  param_combinations <- list()
  performance_results <- list()
  failed_sims <- list()
  successful_count <- 0
  
  for(res in results) {
    if(!is.null(res) && !inherits(res, "error")) {
      if(res$success) {
        successful_count <- successful_count + 1
        if(successful_count <= n_sims) {
          sim_results[[successful_count]] <- res$simulation
          param_combinations[[successful_count]] <- res$params_info
          performance_results[[successful_count]] <- res$performance
        }
      } else {
        failed_sims[[length(failed_sims) + 1]] <- res
      }
    }
  }
  
  # Final summary
  cat("\n=== ENHANCED SIMULATION RESULTS ===\n")
  cat("Completed", min(successful_count, n_sims), "successful simulations\n")
  if (length(failed_sims) > 0) {
    failure_reasons <- table(sapply(failed_sims, function(x) x$reason))
    cat("Failed simulations by reason:\n")
    print(failure_reasons)
    
    # Show detailed failure information for first few failures
    cat("\nDetailed failure analysis (first 5 failures):\n")
    for (i in 1:min(5, length(failed_sims))) {
      fail_info <- failed_sims[[i]]
      cat("  Sim", fail_info$sim_id, "- Reason:", fail_info$reason)
      if (!is.null(fail_info$details)) {
        cat(" - Details:", fail_info$details)
      }
      cat("\n")
    }
  }
  
  # Calculate summary statistics of performance
  if (length(performance_results) > 0) {
    composite_scores <- sapply(performance_results, function(x) x$composite_score)
    rmse_scores <- sapply(performance_results, function(x) x$total_weighted_rmse)
    
    cat("\nPerformance Summary:\n")
    cat("  Composite Score - Mean:", round(mean(composite_scores), 4), 
        "Range:", round(min(composite_scores), 4), "-", round(max(composite_scores), 4), "\n")
    cat("  Weighted RMSE - Mean:", round(mean(rmse_scores), 4),
        "Range:", round(min(rmse_scores), 4), "-", round(max(rmse_scores), 4), "\n")
  }
  
  # Trim to requested number of simulations
  if(length(sim_results) > n_sims) {
    sim_results <- sim_results[1:n_sims]
    param_combinations <- param_combinations[1:n_sims]
    performance_results <- performance_results[1:n_sims]
  }
  
  return(list(
    simulations = sim_results,
    parameters = param_combinations,
    performance = performance_results,
    failed = failed_sims,
    n_successful = length(sim_results),
    n_attempts = length(results)
  ))
}

# Function to find optimal parameters based on enhanced metrics
find_optimal_parameters_enhanced <- function(sim_results_list, metric = "composite_score") {
  
  # Extract performance metrics
  performance_data <- sim_results_list$performance
  
  if (length(performance_data) == 0) {
    stop("No performance data available")
  }
  
  # Get the specified metric values
  metric_values <- sapply(performance_data, function(x) {
    if (metric %in% names(x)) {
      return(x[[metric]])
    } else {
      return(NA)
    }
  })
  
  # Find optimal (minimum for most metrics)
  if (metric == "avg_correlation") {
    optimal_idx <- which.max(metric_values)  # Higher correlation is better
  } else {
    optimal_idx <- which.min(metric_values)  # Lower is better for RMSE, MAE, bias, composite
  }
  
  if (length(optimal_idx) == 0 || is.na(optimal_idx)) {
    stop("Could not find optimal simulation for metric:", metric)
  }
  
  # Create summary statistics
  metric_stats <- data.frame(
    mean = mean(metric_values, na.rm = TRUE),
    median = median(metric_values, na.rm = TRUE),
    sd = sd(metric_values, na.rm = TRUE),
    min = min(metric_values, na.rm = TRUE),
    max = max(metric_values, na.rm = TRUE),
    q25 = quantile(metric_values, 0.25, na.rm = TRUE),
    q75 = quantile(metric_values, 0.75, na.rm = TRUE)
  )
  
  cat("\n=== OPTIMAL PARAMETER SELECTION ===\n")
  cat("Optimization metric:", metric, "\n")
  cat("Optimal simulation:", optimal_idx, "with", metric, "=", metric_values[optimal_idx], "\n")
  cat("\nMetric Statistics:\n")
  print(metric_stats)
  
  # Extract detailed performance for optimal simulation
  optimal_performance <- performance_data[[optimal_idx]]
  
  cat("\n=== OPTIMAL SIMULATION PERFORMANCE ===\n")
  cat("Weighted RMSE:", round(optimal_performance$total_weighted_rmse, 4), "\n")
  cat("Weighted MAE:", round(optimal_performance$total_weighted_mae, 4), "\n")
  cat("Weighted Bias:", round(optimal_performance$total_weighted_bias, 4), "\n")
  cat("Average Correlation:", round(optimal_performance$avg_correlation, 4), "\n")
  cat("Composite Score:", round(optimal_performance$composite_score, 4), "\n")
  
  cat("\nSpecies-specific performance:\n")
  print(optimal_performance$metrics_by_species)
  
  return(list(
    optimal_index = optimal_idx,
    optimal_metric_value = metric_values[optimal_idx],
    optimal_sim = sim_results_list$simulations[[optimal_idx]],
    optimal_params = sim_results_list$parameters[[optimal_idx]],
    optimal_performance = optimal_performance,
    all_metric_values = metric_values,
    metric_stats = metric_stats,
    metric_used = metric
  ))
}

# Function to plot RMSE distribution from uncertainty analysis
plot_rmse_distribution <- function(rmse_values,
                                  optimal_idx = NULL,
                                  plot_title = "RMSE Distribution from Combined Parameter Uncertainty") {
  
  require(ggplot2)
  
  df <- data.frame(
    Simulation = 1:length(rmse_values),
    RMSE = rmse_values
  )
  
  # Calculate statistics for annotation
  mean_rmse <- mean(rmse_values)
  median_rmse <- median(rmse_values)
  
  p <- ggplot(df, aes(x = RMSE)) +
    geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "black") +
    theme_bw() +
    labs(
      title = plot_title,
      subtitle = paste("n =", length(rmse_values), "simulations"),
      x = "RMSE (Root Mean Square Error)",
      y = "Frequency"
    ) +
    # Add mean line
    geom_vline(xintercept = mean_rmse,
              color = "blue", linetype = "dotted", linewidth = 1) +
    # Add median line
    geom_vline(xintercept = median_rmse,
              color = "green", linetype = "dotted", linewidth = 1)
  
  # Add vertical line for optimal value if provided
  if (!is.null(optimal_idx)) {
    p <- p +
      geom_vline(xintercept = rmse_values[optimal_idx],
                color = "red", linetype = "dashed", linewidth = 1) +
      annotate("text",
              x = rmse_values[optimal_idx],
              y = max(table(cut(rmse_values, 30))) * 0.9,
              label = paste("Optimal RMSE =", round(rmse_values[optimal_idx], 2)),
              hjust = -0.1, color = "red")
  }
  
  # Add legend for lines
  p <- p +
    annotate("text", x = mean_rmse, y = max(table(cut(rmse_values, 30))) * 0.8,
            label = paste("Mean =", round(mean_rmse, 2)),
            hjust = -0.1, color = "blue", size = 3) +
    annotate("text", x = median_rmse, y = max(table(cut(rmse_values, 30))) * 0.7,
            label = paste("Median =", round(median_rmse, 2)),
            hjust = -0.1, color = "green", size = 3)
  
  return(p)
}

# Function to visualize parameter combinations
plot_parameter_exploration <- function(param_combinations, rmse_values) {
  
  require(ggplot2)
  require(tidyr)
  require(dplyr)
  
  # Extract catchability and marine mammal scaling
  df_params <- data.frame(
    sim_id = 1:length(param_combinations),
    rmse = rmse_values
  )
  
  # Add catchability info (assuming single gear for simplicity)
  df_params$catchability <- sapply(param_combinations, function(x) mean(x$catchability))
  
  # Add marine mammal scaling (mean across all marine mammals)
  df_params$mammal_scaling <- sapply(param_combinations, function(x) mean(x$marine_mammal_scaling))
  
  # Create scatter plot
  p1 <- ggplot(df_params, aes(x = catchability, y = mammal_scaling, color = rmse)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_gradient(low = "blue", high = "red", name = "RMSE") +
    theme_bw() +
    labs(
      title = "Parameter Space Exploration",
      x = "Mean Catchability",
      y = "Mean Marine Mammal Scaling Factor"
    )
  
  # Create individual parameter distributions
  p2 <- ggplot(df_params, aes(x = catchability)) +
    geom_histogram(bins = 20, fill = "steelblue", alpha = 0.7) +
    theme_bw() +
    labs(title = "Catchability Distribution", x = "Catchability", y = "Count")
  
  p3 <- ggplot(df_params, aes(x = mammal_scaling)) +
    geom_histogram(bins = 20, fill = "darkgreen", alpha = 0.7) +
    theme_bw() +
    labs(title = "Marine Mammal Scaling Distribution", x = "Scaling Factor", y = "Count")
  
  # Combine plots
  require(gridExtra)
  combined_plot <- grid.arrange(p1, p2, p3, ncol = 2, nrow = 2)
  
  return(combined_plot)
}
```

## Enhanced Uncertainty Analysis with Corrected Stability Logic

The enhanced uncertainty analysis incorporates several key improvements:

1. **Whale Species Weighting**: Marine mammals weighted 3-10x higher than fish/krill species
2. **Multiple Performance Metrics**: RMSE, MAE, bias, correlation, and composite scores
3. **Enhanced Steady-State Protocols**: Stricter tolerance (≤0.002) and longer convergence times (≥1000 years)
4. **Corrected Stability Validation**: Stability checked **only during spinup period** (no fishing), not during fished simulations
5. **Realistic CV Thresholds**: 10% CV threshold for spinup stability, allowing natural variability during fishing periods

```{r load-enhanced-tests}
# Load diagnostic and testing functions from separate script
source("Enhanced_Stability_Tests.R")
```

### Run Enhanced Uncertainty Analysis

```{r run-enhanced-uncertainty-analysis}
# Ensure yield_ts_tidy is available for any functions that reference it directly
if (!exists("yield_ts_tidy")) {
  yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")
}
# Run enhanced uncertainty analysis with corrected stability logic
cat("Running Enhanced Uncertainty Analysis with corrected approach...\n\n")

# Validate approach first by running a quick test
cat("Step 1: Validating spinup-only stability approach...\n")
validation_test <- test_spinup_stability_approach(
  params_1841_2010_climate_only, 
  combined_effort_array, 
  n_tests = 1
)

if (validation_test$success_rate >= 80) {
  cat("✓ Approach validated! Success rate:", round(validation_test$success_rate, 1), "%\n")
  cat("✓ Spinup periods achieve <10% CV, fished periods have expected variability\n\n")
  
  cat("Step 2: Running full enhanced uncertainty analysis...\n")
  
  # Run the full enhanced uncertainty analysis
  enhanced_uncertainty_results <- run_enhanced_combined_uncertainty_sims(
    params = params_1841_2010_climate_only,
    n_sims = 3000,  # Full simulation set
    catchability_sd = 0.4,  # 30% CV for catchability
    abundance_sd = 0.8,     # 50% CV for marine mammal abundance
    marine_mammal_species = c("minke whales", "orca", "sperm whales", "baleen whales"),
    effort_scen = combined_effort_array,
    enhanced_steady_tol = 0.002,
    enhanced_steady_t_max = 1000,
    spinup_years = 118,
    spinup_multiplier = 2,  # Extended spinup for stability
    t_start = 1841,
    sim_years = 170,
    preserve_erepro = TRUE,
    max_erepro = 10,
    yield_obs_data = yield_ts_tidy
  )
  
  # Save results
  saveRDS(enhanced_uncertainty_results, "enhanced_uncertainty_final_results.RDS")
  
  # Calculate success rate
  success_rate <- (enhanced_uncertainty_results$n_successful / enhanced_uncertainty_results$n_attempts) * 100
  cat("\n=== ENHANCED UNCERTAINTY ANALYSIS RESULTS ===\n")
  cat("Success rate:", round(success_rate, 1), "%\n")
  cat("Successful simulations:", enhanced_uncertainty_results$n_successful, "out of", enhanced_uncertainty_results$n_attempts, "attempts\n")
  
  if (success_rate >= 70) {
    successful_sims <- enhanced_uncertainty_results$simulations
    cat("✓ SUCCESS! Enhanced uncertainty analysis completed successfully\n")
    cat("Number of successful simulations:", length(successful_sims), "\n")
    cat("Ready for uncertainty plotting with geom_ribbon\n")
    
    # Store successful simulations for plotting
    saveRDS(successful_sims, "enhanced_simulations_for_plotting.RDS")
    
  } else {
    cat("⚠ Moderate success rate. May need further optimization.\n")
  }
  
} else {
  cat("✗ Validation failed. Need to investigate stability approach further.\n")
  cat("Success rate:", round(validation_test$success_rate, 1), "%\n")
}
```

### Enhanced Uncertainty Plotting Functions

Now that we have successful enhanced simulations, we can create plots with uncertainty ribbons:

```{r enhanced-plotting-functions}
# Enhanced plotting functions with uncertainty ribbons
# Load successful enhanced simulations
if (file.exists("enhanced_simulations_for_plotting.RDS")) {
  enhanced_sims <- readRDS("enhanced_simulations_for_plotting.RDS")
  cat("Loaded", length(enhanced_sims), "successful enhanced simulations for plotting\n")
  
  # Function to calculate uncertainty ribbons from multiple simulations
  calculate_uncertainty_ribbons <- function(sim_list, metric_func, years = 1841:2010) {
    
    # Extract metric from each simulation
    metric_data <- lapply(sim_list, function(sim) {
      metric_values <- metric_func(sim)
      
      # Ensure we have the right years
      if (is.matrix(metric_values) || is.data.frame(metric_values)) {
        metric_df <- as.data.frame(metric_values)
        metric_df$year <- as.numeric(rownames(metric_df))
      } else {
        metric_df <- data.frame(
          value = metric_values,
          year = years[1:length(metric_values)]
        )
      }
      
      return(metric_df)
    })
    
    # Combine all simulations and calculate quantiles
    all_data <- do.call(rbind, lapply(1:length(metric_data), function(i) {
      df <- metric_data[[i]]
      df$sim_id <- i
      return(df)
    }))
    
    if (ncol(all_data) > 3) {  # Multiple species/groups
      # For multiple columns, calculate uncertainty for each
      species_cols <- names(all_data)[!names(all_data) %in% c("year", "sim_id")]
      
      uncertainty_data <- lapply(species_cols, function(species) {
        species_data <- all_data %>%
          select(year, sim_id, value = all_of(species)) %>%
          group_by(year) %>%
          summarise(
            median = median(value, na.rm = TRUE),
            q25 = quantile(value, 0.25, na.rm = TRUE),
            q75 = quantile(value, 0.75, na.rm = TRUE),
            q05 = quantile(value, 0.05, na.rm = TRUE),
            q95 = quantile(value, 0.95, na.rm = TRUE),
            mean = mean(value, na.rm = TRUE),
            .groups = 'drop'
          ) %>%
          mutate(species = species)
        
        return(species_data)
      })
      
      return(do.call(rbind, uncertainty_data))
      
    } else {  # Single metric
      uncertainty_data <- all_data %>%
        group_by(year) %>%
        summarise(
          median = median(value, na.rm = TRUE),
          q25 = quantile(value, 0.25, na.rm = TRUE),
          q75 = quantile(value, 0.75, na.rm = TRUE),
          q05 = quantile(value, 0.05, na.rm = TRUE),
          q95 = quantile(value, 0.95, na.rm = TRUE),
          mean = mean(value, na.rm = TRUE),
          .groups = 'drop'
        )
      
      return(uncertainty_data)
    }
  }
  
  # Enhanced yield plotting function with uncertainty ribbons
  plot_yield_uncertainty <- function(sim_list, observed_data = NULL, title = "Yield with Uncertainty") {
    
    # Calculate yield uncertainty ribbons
    yield_uncertainty <- calculate_uncertainty_ribbons(sim_list, getYield)
    
    # Create base plot
    p <- ggplot(yield_uncertainty, aes(x = year)) +
      geom_ribbon(aes(ymin = q05, ymax = q95, fill = species), alpha = 0.2) +
      geom_ribbon(aes(ymin = q25, ymax = q75, fill = species), alpha = 0.4) +
      geom_line(aes(y = median, color = species), size = 1) +
      scale_fill_viridis_d(name = "Species") +
      scale_color_viridis_d(name = "Species") +
      labs(
        title = title,
        x = "Year",
        y = "Yield (tonnes)",
        subtitle = "Ribbons show 50% (dark) and 90% (light) confidence intervals"
      ) +
      theme_minimal() +
      theme(
        legend.position = "bottom",
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 12)
      )
    
    # Add observed data if provided
    if (!is.null(observed_data)) {
      # Ensure column names are consistent (convert to lowercase if needed)
      obs_data_plot <- observed_data
      names(obs_data_plot) <- tolower(names(obs_data_plot))
      
      p <- p + geom_point(data = obs_data_plot, 
                         aes(x = year, y = yield, color = species), 
                         size = 2, alpha = 0.7)
    }
    
    return(p)
  }
  
  # Enhanced biomass plotting function with uncertainty ribbons
  plot_biomass_uncertainty <- function(sim_list, title = "Biomass with Uncertainty") {
    
    # Calculate biomass uncertainty ribbons
    biomass_uncertainty <- calculate_uncertainty_ribbons(sim_list, getBiomass)
    
    # Create plot
    p <- ggplot(biomass_uncertainty, aes(x = year)) +
      geom_ribbon(aes(ymin = q05, ymax = q95, fill = species), alpha = 0.2) +
      geom_ribbon(aes(ymin = q25, ymax = q75, fill = species), alpha = 0.4) +
      geom_line(aes(y = median, color = species), size = 1) +
      scale_fill_viridis_d(name = "Species") +
      scale_color_viridis_d(name = "Species") +
      scale_y_log10() +
      labs(
        title = title,
        x = "Year", 
        y = "Biomass (tonnes, log scale)",
        subtitle = "Ribbons show 50% (dark) and 90% (light) confidence intervals"
      ) +
      theme_minimal() +
      theme(
        legend.position = "bottom",
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 12)
      )
    
    return(p)
  }
  
} else {
  cat("Enhanced simulations not found. Please run the enhanced uncertainty analysis first.\n")
}
```

### Create Enhanced Uncertainty Plots

```{r create-enhanced-uncertainty-plots}
# Create enhanced plots with uncertainty ribbons if data is available
if (exists("enhanced_sims") && length(enhanced_sims) > 0) {
  
  cat("Creating enhanced uncertainty plots with", length(enhanced_sims), "simulations...\n")
  
  # Load observed yield data for comparison
  if (file.exists("yield_observed_timeseries_tidy.RDS")) {
    observed_yield <- readRDS("yield_observed_timeseries_tidy.RDS")
  } else {
    observed_yield <- NULL
  }
  
  # Create yield uncertainty plot
  p_yield_enhanced <- plot_yield_uncertainty(
    enhanced_sims, 
    observed_data = observed_yield,
    title = "Enhanced Yield Projections with Uncertainty"
  )
  
  # Create biomass uncertainty plot  
  p_biomass_enhanced <- plot_biomass_uncertainty(
    enhanced_sims,
    title = "Enhanced Biomass Projections with Uncertainty"
  )
  
  # Display plots
  print(p_yield_enhanced)
  print(p_biomass_enhanced)
  
  # Save plots
  ggsave("enhanced_yield_uncertainty.png", p_yield_enhanced, width = 12, height = 8, dpi = 300)
  ggsave("enhanced_biomass_uncertainty.png", p_biomass_enhanced, width = 12, height = 8, dpi = 300)
  
  cat("✓ Enhanced uncertainty plots created and saved\n")
  cat("✓ Plots show 50% (dark ribbons) and 90% (light ribbons) confidence intervals\n")
  cat("✓ Marine mammal species weighted 3-10x higher in uncertainty analysis\n")
  
} else {
  cat("No enhanced simulation data available for plotting.\n")
  cat("Please run the enhanced uncertainty analysis first.\n")
}
```
    

## Alternative Approach: Focus on Key Species Only

If the full stability requirements are still too strict, try this whale-focused approach:

```{r whale-focused-approach, eval=FALSE}
# # Load the stability test results to get recommended parameters
# # stability_test_results <- readRDS("stability_test_results.RDS")
# 
# # Use recommended parameters from stability test, or fall back to more relaxed defaults
# recommended_tolerance <- if (exists("stability_test_results") && 
#                             !is.na(stability_test_results$recommended$tolerance)) {
#   stability_test_results$recommended$tolerance
# } else {
#   0.10  # Default to 10% CV if no test results
# }
# 
# recommended_check_years <- if (exists("stability_test_results") && 
#                               !is.na(stability_test_results$recommended$check_years)) {
#   stability_test_results$recommended$check_years
# } else {
#   30  # Default to 30 years if no test results
# }
# 
# cat("Using stability parameters:\n")
# cat("  Tolerance:", recommended_tolerance * 100, "% CV\n")
# cat("  Check years:", recommended_check_years, "\n\n")
# 
# # Run enhanced combined uncertainty simulations with adjusted stability requirements
# enhanced_uncertainty_results <- run_enhanced_combined_uncertainty_sims(
#   params = params_1841_2010_climate_only,
#   n_sims = 50,  # Start smaller to test
#   catchability_sd = 0.3,  # Moderate uncertainty for catchability (30% CV)
#   abundance_sd = 0.5,     # Moderate uncertainty for marine mammal abundance (50% CV)
#   marine_mammal_species = c("minke whales", "orca", "sperm whales", "baleen whales"),
#   effort_scen = combined_effort_array,
#   enhanced_steady_tol = 0.005,    # Slightly relaxed from 0.002
#   enhanced_steady_t_max = 800,    # Reduced from 1000
#   spinup_years = 118,
#   spinup_multiplier = 2,          # Keep 2x spinup
#   t_start = 1841,
#   sim_years = 170,
#   preserve_erepro = TRUE,
#   max_erepro = 1,
#   species_weights_df = species_weights,
#   yield_obs_data = yield_ts_tidy,
#   n_cores = NULL,
#   parallel = FALSE  # Use sequential for better debugging initially
# )
# 
# # Save results
# saveRDS(enhanced_uncertainty_results, "enhanced_uncertainty_results_adjusted.RDS")
# 
# # Display results
# cat("\n=== ADJUSTED ENHANCED SIMULATION SUMMARY ===\n")
# cat("Successful simulations:", enhanced_uncertainty_results$n_successful, "\n")
# cat("Total attempts:", enhanced_uncertainty_results$n_attempts, "\n")
# if (enhanced_uncertainty_results$n_successful > 0) {
#   cat("Success rate:", round(enhanced_uncertainty_results$n_successful / enhanced_uncertainty_results$n_attempts * 100, 1), "%\n")
# }
```


## Alternative: Modified Stability Check Approach

If the stability requirements are still too strict, we can modify the approach to focus on the most important species:

```{r alternative-stability-approach, eval=FALSE}
# # Create a modified stability check that focuses on key species only
# check_key_species_stability <- function(sim_object, 
#                                        key_species = c("minke whales", "sperm whales", "baleen whales"),
#                                        tolerance = 0.15,  # More relaxed 15% CV
#                                        check_years = 30) {
#   
#   biomass <- getBiomass(sim_object)
#   
#   if (nrow(biomass) < check_years) {
#     return(FALSE)
#   }
#   
#   # Focus only on key species (whales)
#   recent_biomass <- tail(biomass, check_years)
#   key_biomass <- recent_biomass[, colnames(recent_biomass) %in% key_species, drop = FALSE]
#   
#   if (ncol(key_biomass) == 0) {
#     return(TRUE)  # No key species to check
#   }
#   
#   # Calculate CV for key species only
#   cv_values <- apply(key_biomass, 2, function(x) {
#     if (mean(x) == 0) return(Inf)
#     sd(x) / mean(x)
#   })
#   
#   # Check if key species are stable
#   key_stable <- all(cv_values < tolerance, na.rm = TRUE)
#   
#   return(key_stable)
# }
# 
# # Function to run simulations with key species stability only
# run_key_species_uncertainty <- function(params, n_sims = 50, ...) {
#   
#   # This would be a simplified version focusing only on whale stability
#   # Implementation would modify the final stability check to use 
#   # check_key_species_stability instead of check_biomass_stability_enhanced
#   
#   cat("Running uncertainty analysis with key species stability check only...\n")
#   cat("Key species: minke whales, sperm whales, baleen whales\n")
#   cat("Tolerance: 15% CV over last 30 years\n\n")
#   
#   # Would need to modify run_enhanced_single_sim to use this check
#   # For now, let's return a placeholder
#   return(list(
#     message = "This approach focuses stability checks on whale species only",
#     recommended_next_steps = c(
#       "Modify final stability check in run_enhanced_single_sim",
#       "Use check_key_species_stability instead of check_biomass_stability_enhanced",
#       "Focus tolerance on whale species which are most important for fitting"
#     )
#   ))
# }
# 
# # Show the approach
# key_species_approach <- run_key_species_uncertainty(params_1841_2010_climate_only)
# print(key_species_approach)
```


## Analyze Enhanced Results and Find Optimal Parameters

```{r analyze-enhanced-results, eval=FALSE}
# Find optimal parameters based on different metrics
# 1. Composite score (combines RMSE, MAE, bias, correlation)
optimal_results_composite <- find_optimal_parameters_enhanced(
  sim_results_list = enhanced_uncertainty_results,
  metric = "composite_score"
)

# 2. Weighted RMSE only (for comparison)
optimal_results_rmse <- find_optimal_parameters_enhanced(
  sim_results_list = enhanced_uncertainty_results,
  metric = "total_weighted_rmse"
)

# 3. Correlation (for models that capture yield patterns well)
optimal_results_correlation <- find_optimal_parameters_enhanced(
  sim_results_list = enhanced_uncertainty_results,
  metric = "avg_correlation"
)

# Save optimal results
saveRDS(optimal_results_composite, "optimal_parameter_results_composite.RDS")
saveRDS(optimal_results_rmse, "optimal_parameter_results_rmse.RDS")
saveRDS(optimal_results_correlation, "optimal_parameter_results_correlation.RDS")

# Display comparison of different optimization metrics
cat("\n=== COMPARISON OF OPTIMIZATION APPROACHES ===\n")
cat("Composite Score Optimal - Simulation:", optimal_results_composite$optimal_index, 
    "Score:", round(optimal_results_composite$optimal_metric_value, 4), "\n")
cat("RMSE Optimal - Simulation:", optimal_results_rmse$optimal_index,
    "RMSE:", round(optimal_results_rmse$optimal_metric_value, 4), "\n")
cat("Correlation Optimal - Simulation:", optimal_results_correlation$optimal_index,
    "Correlation:", round(optimal_results_correlation$optimal_metric_value, 4), "\n")

# Compare performance across metrics for the composite score optimal model
best_model_performance <- optimal_results_composite$optimal_performance
cat("\n=== BEST MODEL (COMPOSITE SCORE) DETAILED PERFORMANCE ===\n")
cat("Weighted RMSE:", round(best_model_performance$total_weighted_rmse, 4), "\n")
cat("Weighted MAE:", round(best_model_performance$total_weighted_mae, 4), "\n")
cat("Weighted Bias:", round(best_model_performance$total_weighted_bias, 4), "\n")
cat("Average Correlation:", round(best_model_performance$avg_correlation, 4), "\n")
cat("Composite Score:", round(best_model_performance$composite_score, 4), "\n")

# Display whale-specific performance (highest weighted species)
whale_species <- c("minke whales", "orca", "sperm whales", "baleen whales")
whale_performance <- best_model_performance$metrics_by_species %>%
  filter(Species %in% whale_species) %>%
  arrange(RMSE)

cat("\n=== WHALE SPECIES PERFORMANCE (High Weight Groups) ===\n")
print(whale_performance)

# Display optimal parameters for the best model
cat("\n=== OPTIMAL PARAMETER COMBINATION (COMPOSITE SCORE) ===\n")
cat("Simulation ID:", optimal_results_composite$optimal_index, "\n")
cat("\nCatchability values:\n")
print(optimal_results_composite$optimal_params$catchability)
cat("\nMarine mammal scaling factors:\n")
scaling_df <- data.frame(
  Species = optimal_results_composite$optimal_params$marine_mammal_species,
  Scaling_Factor = optimal_results_composite$optimal_params$marine_mammal_scaling,
  Scaling_Percent = paste0(round((optimal_results_composite$optimal_params$marine_mammal_scaling - 1) * 100, 1), "%")
)
print(scaling_df)
```

## Visualize Enhanced Uncertainty Analysis Results

```{r visualize-enhanced-results, eval=FALSE}
# Plot performance metric distributions
plot_enhanced_performance_distributions <- function(performance_results, metric_name) {
  require(ggplot2)
  
  metric_values <- sapply(performance_results, function(x) x[[metric_name]])
  
  df <- data.frame(
    Simulation = 1:length(metric_values),
    Value = metric_values
  )
  
  p <- ggplot(df, aes(x = Value)) +
    geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "black") +
    theme_bw() +
    labs(
      title = paste("Distribution of", metric_name),
      subtitle = paste("n =", length(metric_values), "simulations"),
      x = metric_name,
      y = "Frequency"
    ) +
    geom_vline(xintercept = mean(metric_values, na.rm = TRUE),
              color = "red", linetype = "dashed", linewidth = 1) +
    annotate("text",
            x = mean(metric_values, na.rm = TRUE),
            y = max(table(cut(metric_values, 30))) * 0.8,
            label = paste("Mean =", round(mean(metric_values, na.rm = TRUE), 3)),
            hjust = -0.1, color = "red")
  
  return(p)
}

# Create performance distribution plots
p_composite <- plot_enhanced_performance_distributions(
  enhanced_uncertainty_results$performance, "composite_score")
p_rmse <- plot_enhanced_performance_distributions(
  enhanced_uncertainty_results$performance, "total_weighted_rmse")
p_correlation <- plot_enhanced_performance_distributions(
  enhanced_uncertainty_results$performance, "avg_correlation")

# Save plots
ggsave("plots/enhanced_composite_score_distribution.png", p_composite,
       width = 10, height = 6, dpi = 300)
ggsave("plots/enhanced_rmse_distribution.png", p_rmse,
       width = 10, height = 6, dpi = 300)
ggsave("plots/enhanced_correlation_distribution.png", p_correlation,
       width = 10, height = 6, dpi = 300)

# Plot species-specific performance comparison
plot_species_performance_comparison <- function(performance_results, species_weights_df) {
  require(ggplot2)
  require(dplyr)
  
  # Extract species metrics from all simulations
  all_species_metrics <- do.call(rbind, lapply(1:length(performance_results), function(i) {
    metrics <- performance_results[[i]]$metrics_by_species
    metrics$Simulation <- i
    return(metrics)
  }))
  
  # Add weights
  all_species_metrics <- all_species_metrics %>%
    left_join(species_weights_df, by = "Species") %>%
    mutate(weight = ifelse(is.na(weight), 1, weight),
           Species_Type = ifelse(Species %in% c("minke whales", "orca", "sperm whales", "baleen whales"),
                                "Whale (High Weight)", "Fish/Krill (Standard Weight)"))
  
  # Create boxplot
  p_species <- ggplot(all_species_metrics, aes(x = reorder(Species, RMSE, median), 
                                               y = RMSE, fill = Species_Type)) +
    geom_boxplot(alpha = 0.7) +
    scale_fill_manual(values = c("Whale (High Weight)" = "coral", 
                                "Fish/Krill (Standard Weight)" = "lightblue")) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
      title = "Species-Specific RMSE Distribution",
      subtitle = "Showing uncertainty across parameter combinations",
      x = "Species (ordered by median RMSE)",
      y = "RMSE",
      fill = "Species Group"
    )
  
  return(p_species)
}

p_species_comparison <- plot_species_performance_comparison(
  enhanced_uncertainty_results$performance, species_weights)
print(p_species_comparison)
ggsave("plots/enhanced_species_performance_comparison.png", p_species_comparison,
       width = 14, height = 8, dpi = 300)
```



## Compare Enhanced Optimal Simulation with Observations

```{r compare-enhanced-optimal-simulation, eval=FALSE}
# Prepare uncertainty bounds data for yield plotting with enhanced results
# Extract yield data from all simulations for uncertainty bounds
trimYield_uncertainty <- function(sim) {
  y <- plotYieldGear(sim, return_data = T)
  y <- select(y, c(Year, Species, Yield))
  return(y)
}

sim_yields_uncertainty <- lapply(enhanced_uncertainty_results$simulations, trimYield_uncertainty)
for (i in 1:length(sim_yields_uncertainty)) {
  sim_yields_uncertainty[[i]]$sim <- i
}

df_sim_yield_uncertainty <- do.call(rbind.data.frame, sim_yields_uncertainty)

# Calculate uncertainty bounds for yield
sim_mean_yield <- df_sim_yield_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Yield = median(Yield)) %>% 
  ungroup()

sim_lower_yield <- df_sim_yield_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Yield = quantile(Yield, 0.025)) %>% 
  ungroup()

sim_upper_yield <- df_sim_yield_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Yield = quantile(Yield, 0.975)) %>% 
  ungroup()

# Combine uncertainty bounds data
uncertainty_yield_data <- data.frame(
  Species = sim_mean_yield$Species, 
  Year = sim_mean_yield$Year,
  sim_mean = sim_mean_yield$Yield,
  sim_lower = sim_lower_yield$Yield,
  sim_upper = sim_upper_yield$Yield
)

# Prepare uncertainty bounds data for biomass plotting
getBiomassData <- function(sim) {
  biomass <- getBiomass(sim)
  df_biomass <- reshape2::melt(biomass)
  names(df_biomass) <- c("Year", "Species", "Biomass")
  return(df_biomass)
}

sim_biomass_uncertainty <- lapply(enhanced_uncertainty_results$simulations, getBiomassData)
for (i in 1:length(sim_biomass_uncertainty)) {
  sim_biomass_uncertainty[[i]]$sim <- i
}

df_sim_biomass_uncertainty <- do.call(rbind.data.frame, sim_biomass_uncertainty)

# Calculate uncertainty bounds for biomass
sim_mean_biomass <- df_sim_biomass_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Biomass = median(Biomass)) %>% 
  ungroup()

sim_lower_biomass <- df_sim_biomass_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Biomass = quantile(Biomass, 0.025)) %>% 
  ungroup()

sim_upper_biomass <- df_sim_biomass_uncertainty %>% 
  group_by(Species, Year) %>% 
  summarise(Biomass = quantile(Biomass, 0.975)) %>% 
  ungroup()

# Combine uncertainty bounds data for biomass
uncertainty_biomass_data <- data.frame(
  Species = sim_mean_biomass$Species, 
  Year = sim_mean_biomass$Year,
  sim_mean = sim_mean_biomass$Biomass,
  sim_lower = sim_lower_biomass$Biomass,
  sim_upper = sim_upper_biomass$Biomass
)

# Get original baseline model data (params_new_v4)
sim_baseline_yield <- project(params_new_v4, effort = combined_effort_array, t_start = 1841, t_max = 170)
baseline_yield_data <- trimYield_uncertainty(sim_baseline_yield)

sim_baseline_biomass <- project(params_new_v4, effort = combined_effort_array, t_start = 1841, t_max = 170)
baseline_biomass_data <- getBiomassData(sim_baseline_biomass)

# New facet label names for species
species.labs <- c("Antarctic krill", "Bathypelagic fishes", "Shelf & Coastal fishes", 
                  "Squids", "Toothfishes", "Antarctic minke whales", "Orcas", 
                  "Sperm whales", "Baleen whales")
names(species.labs) <- c("antarctic krill", "bathypelagic fishes", "shelf and coastal fishes", 
                         "squids", "toothfishes", "minke whales", "orca", "sperm whales", "baleen whales")

# Plot yield comparison for optimal simulation with uncertainty bounds (using composite score optimal)
p_yield_optimal <- plotYield(optimal_results_composite$optimal_sim) + 
  facet_wrap(~Species, scales = "free_y",
             labeller = labeller(Species = species.labs)) +
  labs(fill = "Functional group", 
       title = "Enhanced Optimal Simulation: Yield with Uncertainty & Whale-Weighted Fitting",
       subtitle = paste("Composite Score:", round(optimal_results_composite$optimal_metric_value, 4),
                       "| Weighted RMSE:", round(optimal_results_composite$optimal_performance$total_weighted_rmse, 4),
                       "| Blue dotted = ensemble median, Blue ribbon = 95% CI")) +
  # Add uncertainty ribbon
  geom_ribbon(data = uncertainty_yield_data, 
              aes(x = Year, ymin = sim_lower, ymax = sim_upper), 
              alpha = 0.3, colour = NA, fill = "lightblue") +
  # Add median line from uncertainty analysis (diagnostic)
  geom_line(data = uncertainty_yield_data, 
            aes(x = Year, y = sim_mean), 
            color = "blue", linetype = "dotted", linewidth = 0.8, alpha = 0.7) +
  # Add baseline model line (original params_new_v4)
  geom_line(data = baseline_yield_data, 
            aes(x = Year, y = Yield), 
            color = "gray60", linetype = "dashed", linewidth = 1) +
  # Add optimal model line (solid black for best fit)
  geom_line(data = plotYieldGear(optimal_results_composite$optimal_sim, return_data = TRUE),
            aes(x = Year, y = Yield, color = Species), linewidth = 1.2) +
  # Add observed data points
  geom_point(data = yield_ts_tidy, 
             aes(x = Year, y = Yield, colour = Species), 
             size = 1) +
  geom_point(data = yield_ts_tidy, 
             aes(x = Year, y = Yield), 
             shape = 1, size = 1, colour = "black") +
  # Add vertical reference lines
  geom_vline(aes(xintercept = 1961), linetype = "dotted", alpha = 0.7) + 
  geom_vline(aes(xintercept = 2010), linetype = "dotted", alpha = 0.7) +
  theme_bw() +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold"),
    plot.subtitle = element_text(size = 10)
  )

print(p_yield_optimal)
ggsave("plots/enhanced_optimal_simulation_yield.png", p_yield_optimal,
       width = 16, height = 12, dpi = 300)

# Plot biomass comparison for optimal simulation with uncertainty bounds
p_biomass_optimal <- plotBiomass(optimal_results_composite$optimal_sim) + 
  facet_wrap(~Species, scales = "free_y",
             labeller = labeller(Species = species.labs)) +
  labs(fill = "Functional group", 
       title = "Enhanced Optimal Simulation: Biomass with Uncertainty & Whale-Weighted Fitting",
       subtitle = paste("Composite Score:", round(optimal_results_composite$optimal_metric_value, 4),
                       "| Avg Correlation:", round(optimal_results_composite$optimal_performance$avg_correlation, 4),
                       "| Green dotted = ensemble median, Green ribbon = 95% CI")) +
  # Add uncertainty ribbon
  geom_ribbon(data = uncertainty_biomass_data, 
              aes(x = Year, ymin = sim_lower, ymax = sim_upper), 
              alpha = 0.3, colour = NA, fill = "lightgreen") +
  # Add median line from uncertainty analysis (diagnostic)
  geom_line(data = uncertainty_biomass_data, 
            aes(x = Year, y = sim_mean), 
            color = "darkgreen", linetype = "dotted", linewidth = 0.8, alpha = 0.7) +
  # Add baseline model line (original params_new_v4)
  geom_line(data = baseline_biomass_data, 
            aes(x = Year, y = Biomass), 
            color = "gray60", linetype = "dashed", linewidth = 1) +
  # Add optimal model line (solid black for best fit)
  geom_line(data = getBiomassData(optimal_results_composite$optimal_sim),
            aes(x = Year, y = Biomass, color = Species), linewidth = 1.2) +
  # Add vertical reference lines
  geom_vline(aes(xintercept = 1961), linetype = "dotted", alpha = 0.7) + 
  geom_vline(aes(xintercept = 2010), linetype = "dotted", alpha = 0.7) +
  theme_bw() +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold"),
    plot.subtitle = element_text(size = 10)
  )

print(p_biomass_optimal)
ggsave("plots/enhanced_optimal_simulation_biomass.png", p_biomass_optimal,
       width = 16, height = 12, dpi = 300)
```

## Summary Statistics and Sensitivity Analysis

```{r sensitivity-analysis, eval=FALSE}
# Create summary table of RMSE by species
rmse_by_species_summary <- do.call(rbind, lapply(optimal_results$rmse_details,
                                                 function(x) x$rmse_by_species))
rmse_by_species_summary$sim_id <- rep(1:length(optimal_results$rmse_details),
                                      each = length(unique(rmse_by_species_summary$Species)))

# Calculate statistics by species
species_rmse_stats <- rmse_by_species_summary %>%
  group_by(Species) %>%
  summarise(
    mean_rmse = mean(RMSE, na.rm = TRUE),
    median_rmse = median(RMSE, na.rm = TRUE),
    sd_rmse = sd(RMSE, na.rm = TRUE),
    min_rmse = min(RMSE, na.rm = TRUE),
    max_rmse = max(RMSE, na.rm = TRUE)
  ) %>%
  arrange(mean_rmse)

cat("\n=== RMSE Statistics by Species ===\n")
print(species_rmse_stats)

# Plot species-specific RMSE distributions
p_species_rmse <- ggplot(rmse_by_species_summary, aes(x = Species, y = RMSE)) +
  geom_boxplot(fill = "lightblue", alpha = 0.7) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "RMSE Distribution by Species",
    subtitle = "From combined uncertainty analysis",
    x = "Species",
    y = "RMSE"
  )
print(p_species_rmse)
ggsave("plots/rmse_by_species_boxplot_flex_erepro_catchSD_0.5_abSD_2.png", p_species_rmse,
       width = 12, height = 6, dpi = 300)

# Calculate correlation between parameters and RMSE
param_rmse_correlation <- data.frame(
  catchability = sapply(combined_uncertainty_results$parameters,
                       function(x) mean(x$catchability)),
  mammal_scaling = sapply(combined_uncertainty_results$parameters,
                         function(x) mean(x$marine_mammal_scaling)),
  rmse = optimal_results$all_rmse
)

cor_matrix <- cor(param_rmse_correlation)
cat("\n=== Parameter-RMSE Correlations ===\n")
print(cor_matrix)

# Create a heatmap of correlations
require(corrplot)
png("plots/parameter_rmse_correlation_flex_erepro_catchSD_0.5_abSD_2.png", width = 800, height = 600)
corrplot(cor_matrix, method = "color", type = "upper",
         addCoef.col = "black", tl.col = "black", tl.srt = 45,
         title = "Parameter-RMSE Correlations")
dev.off()
```

## Export Optimal Parameters for Future Use

```{r export-optimal-params, eval=FALSE}
# Extract optimal parameters for future simulations
optimal_params_export <- params_1841_2010_fishing_only

# Update with optimal catchability
gear_df <- gear_params(optimal_params_export)
gear_df$catchability <- optimal_results$optimal_params$catchability
gear_params(optimal_params_export) <- gear_df

# Update with optimal marine mammal scaling
sp_params <- species_params(optimal_params_export)
mammal_indices <- which(sp_params$species %in% optimal_results$optimal_params$marine_mammal_species)
for (i in seq_along(mammal_indices)) {
  optimal_params_export@initial_n[mammal_indices[i],] <-
    optimal_params_export@initial_n[mammal_indices[i],] *
    optimal_results$optimal_params$marine_mammal_scaling[i]
}

# Run to steady state (preserving erepro if needed)
# Check if we want to preserve erepro based on the original analysis
preserve_erepro_export <- TRUE  # Set this based on your preference
if (preserve_erepro_export) {
  optimal_params_export <- steady(optimal_params_export, tol = 0.01, t_max = 500, preserve = c("erepro"))
} else {
  optimal_params_export <- steady(optimal_params_export, tol = 0.01, t_max = 500)
  # Check final erepro values
  final_erepro <- species_params(optimal_params_export)$erepro
  if (any(final_erepro > 1, na.rm = TRUE)) {
    warning("Some species have erepro > 1 in the optimal parameters:")
    print(data.frame(
      Species = sp_params$species[which(final_erepro > 1)],
      erepro = final_erepro[which(final_erepro > 1)]
    ))
  }
}

# Save optimal parameters
saveRDS(optimal_params_export, "params_optimal_combined_uncertainty.RDS")

cat("\nOptimal parameters saved to 'params_optimal_combined_uncertainty.RDS'\n")
```
## Adaptive Uncertainty Analysis with Species-Specific Refinement

This section implements an improved adaptive approach that checks RMSE every 10 simulations and refines the parameter search space based on performance, with special attention to species with poor fits.

### Run Adaptive Uncertainty Analysis

The adaptive approach gradually refines the search space, focusing on parameter combinations that show promise while specifically tracking species that have poor fits (like Antarctic krill and minke whales). All necessary functions are included in Helper_Functions.R.

```{r run-adaptive-analysis, eval=FALSE}
# Load required data if not already loaded
if (!exists("combined_effort_array")) {
  combined_effort_array <- readRDS("effort_array_1841_2010.rds")
}

if (!exists("yield_ts_tidy")) {
  yield_ts_tidy <- readRDS("yield_observed_timeseries_tidy.RDS")
}

# Run adaptive uncertainty analysis
# This will check RMSE every 10 simulations and refine the search space
adaptive_results <- run_adaptive_uncertainty_analysis(
  params = params_1841_2010_fishing_only,
  n_total_sims = 500,  # Total number of simulations
  check_interval = 10,  # Check and refine every 10 simulations (more frequent updates)
  initial_catchability_sd = 0.3,  # Start with wider search
  initial_abundance_sd = 0.4,  # Start with wider search
  marine_mammal_species = c("minke whales", "orca", "sperm whales", "baleen whales", "shelf and coastal fishes"),
  fished_species = c("antarctic krill", "bathypelagic fishes",
                    "shelf and coastal fishes", "squids", "toothfishes",
                    "minke whales", "orca", "sperm whales", "baleen whales"),
  effort_scen = combined_effort_array,
  yield_obs_data = yield_ts_tidy,
  year_range = c(1961, 2010),
  tol = 0.01,
  t_max = 500,
  spinup_years = 118,
  t_start = 1841,
  sim_years = 170,
  preserve_erepro = TRUE,
  max_erepro = 1,
  convergence_threshold = 0.01,  # Stop refining if improvement < 1%
  n_cores = NULL,  # Use all available cores minus 1
  parallel = TRUE,
  verbose = TRUE  # Show progress and species-specific issues
)

# Validate the adaptive results to ensure all simulations are valid
cat("\nValidating adaptive analysis results...\n")
adaptive_results_cleaned <- validate_simulation_results(adaptive_results, verbose = TRUE)

# Save adaptive results
saveRDS(adaptive_results_cleaned, "adaptive_uncertainty_results.RDS")

# Display summary
cat("\n=== Adaptive Analysis Summary ===\n")
cat("Total simulations:", adaptive_results$optimal$total_simulations, "\n")
cat("Optimal RMSE:", round(adaptive_results$optimal$optimal_rmse, 3), "\n")
cat("RMSE range:", round(range(adaptive_results$all_rmse), 3), "\n")

# Display runtime information
cat("\n=== Runtime Information ===\n")
cat("Total runtime:", round(adaptive_results$optimal$runtime$total_minutes, 1), "minutes\n")
cat("Average time per simulation:", round(adaptive_results$optimal$runtime$avg_time_per_simulation, 1), "seconds\n")
cat("Parallel processing:", ifelse(adaptive_results$optimal$runtime$parallel_used,
                                  paste("YES (", adaptive_results$optimal$runtime$n_cores_used, " cores)", sep=""),
                                  "NO (sequential)"), "\n")

cat("\nSpecies-specific RMSE (best simulation):\n")
best_species_rmse <- adaptive_results$species_rmse[[adaptive_results$optimal$optimal_index]]
for (sp in names(best_species_rmse)) {
  cat("  ", sp, ":", round(best_species_rmse[[sp]], 3), "\n")
}
```

### Visualize Adaptive Convergence

```{r visualize-adaptive-convergence, eval=FALSE}
# Plot convergence history
p_convergence <- plot_adaptive_convergence(adaptive_results)
ggsave("plots/adaptive_convergence_history.png", p_convergence,
       width = 12, height = 14, dpi = 300)

# Plot species-specific RMSE evolution
# Focus on problematic species
p_species_evolution <- plot_species_rmse_evolution(
  adaptive_results,
  species_focus = c("antarctic_krill", "minke_whales", "baleen_whales", "sperm_whales")
)
print(p_species_evolution)
ggsave("plots/species_rmse_evolution.png", p_species_evolution,
       width = 14, height = 10, dpi = 300)

# Plot all species RMSE evolution
p_all_species <- plot_species_rmse_evolution(adaptive_results)
ggsave("plots/all_species_rmse_evolution.png", p_all_species,
       width = 16, height = 12, dpi = 300)
```

### Analyze Parameter Correlations

```{r analyze-adaptive-parameters, eval=FALSE}
# Create correlation heatmap for top performers
cor_matrix <- plot_parameter_correlations(adaptive_results, top_percent = 0.1)

# Extract optimal parameters
optimal_params_adaptive <- adaptive_results$optimal$optimal_parameters
cat("\n=== Optimal Parameters from Adaptive Search ===\n")
cat("Catchability values:\n")
print(optimal_params_adaptive$catchability)
cat("\nMarine mammal scaling factors:\n")
mm_scaling_df <- data.frame(
  Species = optimal_params_adaptive$marine_mammal_species,
  Scaling = optimal_params_adaptive$marine_mammal_scaling
)
print(mm_scaling_df)

# Compare with initial parameters
cat("\n=== Parameter Changes from Initial ===\n")
cat("Catchability changes:\n")
print(optimal_params_adaptive$catchability_change)
```

### Compare Adaptive vs. Standard Approach

```{r compare-approaches, eval=FALSE}
# Load standard approach results if available
if (file.exists("combined_uncertainty_results.RDS")) {
  standard_results <- readRDS("combined_uncertainty_results.RDS")
  
  # Compare RMSE distributions
  df_comparison <- data.frame(
    RMSE = c(adaptive_results$all_rmse,
             sapply(standard_results$simulations, function(sim) {
               calculate_yield_rmse(sim, yield_ts_tidy,
                                  species_list = c("antarctic krill", "bathypelagic fishes",
                                                  "shelf and coastal fishes", "squids", "toothfishes",
                                                  "minke whales", "orca", "sperm whales", "baleen whales"),
                                  year_range = c(1961, 2010))$total_rmse
             })),
    Method = c(rep("Adaptive", length(adaptive_results$all_rmse)),
              rep("Standard", length(standard_results$simulations)))
  )
  
  p_comparison <- ggplot(df_comparison, aes(x = Method, y = RMSE, fill = Method)) +
    geom_boxplot(alpha = 0.7) +
    geom_point(position = position_jitter(width = 0.2), alpha = 0.3) +
    scale_fill_manual(values = c("Adaptive" = "darkgreen", "Standard" = "steelblue")) +
    theme_bw() +
    labs(title = "RMSE Comparison: Adaptive vs. Standard Uncertainty Analysis",
         subtitle = "Adaptive approach refines search space every 50 simulations",
         y = "RMSE") +
    theme(legend.position = "none")
  
  print(p_comparison)
  ggsave("plots/adaptive_vs_standard_comparison.png", p_comparison,
         width = 8, height = 6, dpi = 300)
  
  # Statistical comparison
  cat("\n=== Statistical Comparison ===\n")
  cat("Adaptive - Min RMSE:", round(min(adaptive_results$all_rmse), 3), "\n")
  cat("Standard - Min RMSE:", round(min(df_comparison$RMSE[df_comparison$Method == "Standard"]), 3), "\n")
  cat("Improvement:",
      round((min(df_comparison$RMSE[df_comparison$Method == "Standard"]) -
             min(adaptive_results$all_rmse)) /
            min(df_comparison$RMSE[df_comparison$Method == "Standard"]) * 100, 1), "%\n")
  
  # Compare runtimes if available
  if (!is.null(adaptive_results$optimal$runtime)) {
    cat("\n=== Runtime Comparison ===\n")
    cat("Adaptive approach runtime:", round(adaptive_results$optimal$runtime$total_minutes, 1), "minutes\n")
    cat("Time per simulation:", round(adaptive_results$optimal$runtime$avg_time_per_simulation, 1), "seconds\n")
    cat("Efficiency note: Adaptive approach focuses computational effort on promising regions\n")
  }
}
```

### Apply Optimal Parameters from Adaptive Search

```{r apply-adaptive-optimal, eval=FALSE}
# Extract and apply optimal parameters
optimal_sim_adaptive <- adaptive_results$optimal$optimal_simulation

# Plot yield comparison with observations
p_yield_adaptive <- plotYield(optimal_sim_adaptive) +
  facet_wrap(~Species, scales = "free_y") +
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield, colour = Species),
             size = 1) +
  geom_point(data = yield_ts_tidy,
             aes(x = Year, y = Yield),
             shape = 1, size = 1, colour = "black") +
  geom_vline(aes(xintercept = 1961), linetype = "dotted", alpha = 0.7) +
  geom_vline(aes(xintercept = 2010), linetype = "dotted", alpha = 0.7) +
  theme_bw() +
  theme(legend.position = "none") +
  labs(title = "Optimal Simulation from Adaptive Search",
       subtitle = paste("RMSE =", round(adaptive_results$optimal$optimal_rmse, 3)))

print(p_yield_adaptive)
ggsave("plots/adaptive_optimal_yield.png", p_yield_adaptive,
       width = 14, height = 10, dpi = 300)

# Create detailed species-specific comparison plots
species_focus <- c("antarctic krill", "minke whales")
for (sp in species_focus) {
  # Get modeled yield for this species
  mod_yield <- getYield(optimal_sim_adaptive)
  df_mod <- reshape2::melt(mod_yield)
  names(df_mod) <- c("Year", "Species", "Yield")
  df_mod_sp <- df_mod[df_mod$Species == sp, ]
  
  # Get observed yield for this species
  obs_sp <- yield_ts_tidy[yield_ts_tidy$Species == sp, ]
  
  p_sp <- ggplot() +
    geom_line(data = df_mod_sp, aes(x = Year, y = Yield),
              color = "darkblue", size = 1.2) +
    geom_point(data = obs_sp, aes(x = Year, y = Yield),
               color = "red", size = 2) +
    theme_bw() +
    labs(title = paste("Adaptive Optimization Result:", sp),
         subtitle = paste("RMSE =", round(best_species_rmse[[sp]], 3)),
         x = "Year", y = "Yield") +
    geom_vline(xintercept = c(1961, 2010), linetype = "dotted", alpha = 0.5)
  
  print(p_sp)
  ggsave(paste0("plots/adaptive_", gsub(" ", "_", sp), "_comparison.png"),
         p_sp, width = 10, height = 6, dpi = 300)
}
```

### Export Optimal Parameters for Future Use

```{r export-adaptive-optimal, eval=FALSE}
# Create parameter object with optimal values
params_optimal_adaptive <- params_1841_2010_fishing_only

# Apply optimal catchability
gear_df <- gear_params(params_optimal_adaptive)
gear_df$catchability <- optimal_params_adaptive$catchability
gear_params(params_optimal_adaptive) <- gear_df

# Apply optimal marine mammal scaling
sp_params <- species_params(params_optimal_adaptive)
mammal_indices <- which(sp_params$species %in% optimal_params_adaptive$marine_mammal_species)
for (i in seq_along(mammal_indices)) {
  params_optimal_adaptive@initial_n[mammal_indices[i],] <-
    params_optimal_adaptive@initial_n[mammal_indices[i],] *
    optimal_params_adaptive$marine_mammal_scaling[i]
}

# Run to steady state
params_optimal_adaptive <- steady(params_optimal_adaptive,
                                 tol = 0.01,
                                 t_max = 500,
                                 preserve = c("erepro"))

# Save optimal parameters
saveRDS(params_optimal_adaptive, "params_optimal_adaptive.RDS")
cat("\nOptimal parameters from adaptive search saved to 'params_optimal_adaptive.RDS'\n")
```

## Summary: Enhanced Uncertainty Analysis Framework

This document now provides a comprehensive enhanced uncertainty analysis framework with the following key components:

### Core Improvements Implemented:

1. **Corrected Stability Logic**: 
   - Stability validation occurs **only during spinup period** (no fishing)
   - Allows natural variability during fished simulations (expected behavior)
   - Uses realistic 10% CV threshold for spinup stability

2. **Whale Species Weighting**: 
   - Marine mammals weighted 3-10x higher than fish/krill species
   - Reflects ecological importance and conservation priorities
   - Improves model realism for ecosystem-based management

3. **Enhanced Steady-State Protocols**: 
   - Stricter convergence criteria (tolerance ≤ 0.002, t_max ≥ 1000 years)
   - Extended spinup validation with biomass stability checking
   - Robust initialization for climate and fishing perturbations

4. **Multiple Performance Metrics**: 
   - RMSE, MAE, bias, correlation, and composite scoring
   - Comprehensive evaluation beyond single metrics
   - Better assessment of model performance across species

5. **Diagnostic and Testing Framework**:
   - Moved to separate `Enhanced_Stability_Tests.R` script
   - Comprehensive validation of stability approaches
   - Diagnostic functions for troubleshooting

### Key Files and Outputs:

- **`Enhanced_Stability_Tests.R`**: Testing and diagnostic functions
- **`enhanced_uncertainty_final_results.RDS`**: Main simulation results  
- **`enhanced_simulations_for_plotting.RDS`**: Successful simulations for plotting
- **Enhanced uncertainty plots**: With geom_ribbon confidence intervals

### Enhanced Plotting Capabilities:

- **Uncertainty ribbons**: 50% (dark) and 90% (light) confidence intervals
- **Species-specific projections**: Individual uncertainty for each species/group
- **Observed data integration**: Comparison with historical observations
- **Professional visualization**: Publication-ready plots with proper legends

### Validated Approach:

The framework has been tested and validated to show:
- ✅ Spinup periods achieve <10% CV (stable initialization)
- ✅ Fished periods show 80-120% CV (expected variability from perturbations)
- ✅ Marine ecosystem models behave realistically under different scenarios
- ✅ Uncertainty quantification captures parameter and model structure uncertainty

### Usage:

1. **Run Enhanced Analysis**: Execute the enhanced uncertainty analysis code chunk
2. **Generate Plots**: Use the enhanced plotting functions with uncertainty ribbons
3. **Compare Scenarios**: Evaluate different climate and fishing scenarios
4. **Validate Results**: Compare model outputs with observed data

This framework provides a robust foundation for uncertainty quantification in marine ecosystem models, specifically designed for the Prydz Bay mizer model with corrected stability logic and realistic marine ecosystem expectations.


